<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CL MiniSpec: List Structure</title>
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="shortcut icon" href="./include/fav.png">-->
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata">
    <link rel="stylesheet" href="./include/highlight-lisp.css">
    <link rel="stylesheet" href="./include/style.css">
    <meta name="description" content="">
  </head>
  <body>
    <div>

      <header>
        <div class="section-padding">
<nav id="navbar">
  <h1><a href="./index.html" class="brand">Common Lisp MiniSpec</a></h1>
  <ul>
    <li><a href="#"><span class="caret">&#x25BC;</span>Symbols</a>
      <ul>
        <li><a href="./symbol.html">Overview</a></li>
        <li><a href="./symbol.html#variables">Variable</a></li>
        <li><a href="./symbol.html#functions">Function</a></li>
        <li><a href="./symbol.html#macros">Macro</a></li>
        <li><a href="./package.html#symbols">Symbol</a></li>
        <li><a href="./package.html#packages">Package</a></li>
        <li><a href="#">System</a></li>
      </ul>
    </li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Collections</a>
      <ul>
        <li><a href="./list.html">List</a></li>
        <li><a href="./list-structure.html#set-functions">Set Functions</a></li>
        <li><a href="./list-structure.html#tree-functions">Tree Functions</a></li>
        <li><a href="./list-structure.html#association-list-alist">Association List</a></li>
        <li><a href="./list-structure.html#property-list-plist">Property List</a></li>
        <li><a href="./array.html">Array</a></li>
        <li><a href="./vector.html">Vector</a></li>
        <li><a href="./string.html">String</a></li>
        <li><a href="./hash-table.html">Hash Table</a></li>
        <li><a href="./structure.html">Struct</a></li>
        <li><a href="./object-system.html">Object System</a></li>
      </ul>
    </li>
    <li><a href="./math.html">Math</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Iteration</a>
      <ul>
        <li><a href="./iteration.html">Iteration</a></li>
        <li><a href="./loop-iterate.html">Loop/Iterate</a></li>
      </ul>
    </li>
    <li><a href="./control.html">Control</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>I/O</a>
      <ul>
        <li><a href="./stream.html">Stream</a></li>
        <li><a href="./read.html">Read</a></li>
        <li><a href="./print.html">Print</a></li>
        <li><a href="./print.html#format">Format</a></li>
        <li><a href="./file.html">File</a></li>
        <li><a href="./file.html#pathnames">Pathname</a></li>
      </ul>
    </li>
    <li><a href="./types.html">Types</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>More</a>
      <ul>
        <li><a href="./comparison.html">Comparison</a></li>
        <li><a href="./composition.html">Composition</a></li>
        <li><a href="./compile.html">Compiler</a></li>
        <li><a href="./time.html">Time</a></li>
        <li><a href="./regular-expression.html">Regular Expressions</a></li>
      </ul>
    </li>
    <li><form><input type="search" placeholder="symbol"></input></form></li>
  </ul>
</nav>
        </div>
      </header>
      
      <div class="article-wrapper">
        <article>
          <div class="section-padding">
<h1 id="list-structures">List Structures</h1>
<h2 id="set-functions">Set Functions</h2>
<ul>
<li><a href="http://www.gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html#sets">PCL: Beyond Lists: Other Uses for Cons Cells</a></li>
</ul>
<h3 id="alexandriasetp-object-key-test-key-boolean"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-setp">alexandria:setp</a> object &amp;key test key &rArr; boolean</h3>
<p>Test if <em>object</em> is a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a> containing unique elements.</p>
<pre><code>(setp &#39;(a b c)) ;&rArr; T
(setp &#39;(a b b)) ;&rArr; NIL
(setp &#39;((10 :a) (10.0 :b)) :key #&#39;car)           ;&rArr; T
(setp &#39;((10 :a) (10.0 :b)) :key #&#39;car :test #&#39;=) ;&rArr; NIL</code></pre>
<h3 id="subsetp-list1-list2-key-key-test-test-not-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_subset.htm">subsetp</a> list1 list2 &amp;key key test test-not &rArr; boolean</h3>
<p>Test if every element of <em>list1</em> matches an element in <em>list2</em>.</p>
<pre><code>(subsetp &#39;(c b a) &#39;(a b c d)) ;&rArr; T
(subsetp &#39;(a b c d) &#39;(c b a)) ;&rArr; NIL</code></pre>
<h3 id="alexandriaset-equal-list1-list2-key-test-key-boolean"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-set_002dequal">alexandria:set-equal</a> list1 list2 &amp;key test key &rArr; boolean</h3>
<p>Test if every element in <em>list1</em> matches an element in <em>list2</em>, and vice-versa.</p>
<pre><code>(set-equal &#39;(a b c) &#39;(c b a)) ;&rArr; T
(set-equal &#39;(a b) &#39;(a b c))   ;&rArr; NIL</code></pre>
<h3 id="member-item-list-key-key-test-test-not-tail"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_member.htm">member</a> item list &amp;key key test test-not &rArr; tail</h3>
<p>Similiar to <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find</a>, but if the item is in the list return the tail, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mem_m.htm">member-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mem_m.htm">member-if-not</a>.</p>
<pre><code>(member &#39;c &#39;(a b c d))             ;&rArr; (C D)
(member-if #&#39;evenp &#39;(1 2 3 4))     ;&rArr; (2 3 4)
(member-if-not #&#39;evenp &#39;(1 2 3 4)) ;&rArr; (1 2 3 4)</code></pre>
<h3 id="adjoin-item-list-key-key-test-test-not-new-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_adjoin.htm">adjoin</a> item list &amp;key key test test-not &rArr; new-list</h3>
<p>Add item to <em>list</em> if not already there, otherwise return original list. Use <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_pshnew.htm">pushnew</a> to modify the original list.</p>
<h3 id="union-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_unionc.htm">union</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>To save the result in place, use <a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-unionf">alexandria:unionf</a>.</p>
<pre><code>(union &#39;(a b c) &#39;(f a d)) ;&rArr; (A B C D F)</code></pre>
<h3 id="intersection-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_isec_.htm">intersection</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>Return a list that contains every element in both <em>list1</em> and <em>list2</em>.</p>
<pre><code>(intersection &#39;(a b c) &#39;(b c d)) ;&rArr; (B C)</code></pre>
<h3 id="set-difference-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_set_di.htm">set-difference</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>Returns a list of elements of <em>list1</em> that do not appear in <em>list2</em>.</p>
<pre><code>(set-difference &#39;(a b c e) &#39;(b c d)) ;&rArr; (A E)</code></pre>
<h3 id="set-exclusive-or-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_set_ex.htm">set-exclusive-or</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>Returns a list of elements that appear in exactly one of <em>list1</em> and <em>list2</em>.</p>
<pre><code>(set-exclusive-or &#39;(a b c e) &#39;(b c d)) ;&rArr; (A D E)</code></pre>
<h2 id="tree-functions">Tree Functions</h2>
<p>Lists of lists.</p>
<ul>
<li><a href="http://www.gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html#trees">PCL: Beyond Lists: Other Uses for Cons Cells</a></li>
</ul>
<h3 id="tree-equal"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_tree_e.htm">tree-equal</a></h3>
<p>Compares two trees, equal if structure is same shape and leaves are eql (or :test).</p>
<h3 id="copy-tree-tree-new-tree"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cp_tre.htm">copy-tree</a> tree &rArr; new-tree</h3>
<p>Creates a copy of a <em>tree</em> of conses.</p>
<h3 id="subst-new-old-tree-key-key-test-test-not-new-tree"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst</a> new old tree &amp;key key test test-not &rArr; new-tree</h3>
<p>Make a copy of <em>tree</em> with each subtree or leaf matching <em>old</em> replaced by <em>new</em>, the tree counterpart to <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute</a>. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst-if-not</a>, called on each atomic value in the tree. The destructive version is <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">nsubst</a> and variants.</p>
<pre><code>(subst &quot;two&quot; 2 &#39;(1 (1 2) (1 (2 3)))) ;&rArr; (1 (1 &quot;two&quot;) (1 (&quot;two&quot; 3)))
(subst-if &quot;one&quot; #&#39;(lambda (x) (equal x 1)) &#39;(1 2 (3 2 1))) ;&rArr; (&quot;one&quot; 2 (3 2 &quot;one&quot;)))</code></pre>
<h3 id="sublis-alist-tree-key-key-test-test-not-new-tree"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sublis.htm">sublis</a> alist tree &amp;key key test test-not &rArr; new-tree</h3>
<p>Make a tree copy and substitute multiple leaves using an <em>alist</em>.</p>
<pre><code>(sublis &#39;((1 . &quot;one&quot;) (2 . &quot;two&quot;)) &#39;(1 (1 2) (1 (2 3))))
  ;&rArr; (&quot;one&quot; (&quot;one&quot; &quot;two&quot;) (&quot;one&quot; (&quot;two&quot; 3))))</code></pre>
<h3 id="alexandriaflatten-tree-list"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-flatten">alexandria:flatten</a> tree &rArr; list</h3>
<p>Collect non-null leaves into a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a>.</p>
<pre><code>(flatten &#39;(1 2 (3 2 1) ((1 1 nil) (2 2)))) ;&rArr; (1 2 3 2 1 1 1 2 2)</code></pre>
<h3 id="alexandriacircular-tree-p-object-boolean"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-circular_002dtree_002dp">alexandria:circular-tree-p</a> object &rArr; boolean</h3>
<p>Test if <em>object</em> is a circular <em>tree</em>.</p>
<h2 id="property-list-plist">Property List (plist)</h2>
<p>Lists with alternating keys and values: <code>(:x 10 :y 20)</code>. Uses <code>#'eq</code> for <code>:test</code>, so should only use symbols as keywords.</p>
<p>Every symbol contains metadata on it stored as a plist:</p>
<pre><code>(symbol-plist &#39;symbol) ;access plist of symbol
(get &#39;symbol &#39;key) ;equivalent to (getf (symbol-plist &#39;symbol)
(setf (get &#39;symbol :my-key) &quot;information&quot;) ;set value
(remprop &#39;symbol &#39;my-key) ;remove property, same as (remf (symbol-plist &#39;symbol) &#39;my-key)</code></pre>
<h3 id="getf-plist-indicator-optional-default-value"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_getf.htm">getf</a> plist indicator &amp;optional default &rArr; value</h3>
<pre><code>(getf plist :x)           ;&rArr; 10
(setf (getf plist :x) 30) ;&rArr; 30</code></pre>
<h3 id="remf-place-indicator-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_remf.htm">remf</a> place indicator &rArr; boolean</h3>
<pre><code>(remf plist :x) ;&rArr; T</code></pre>
<h3 id="get-properties-plist-indicator-list-indicator-value-tail"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_get_pr.htm">get-properties</a> plist indicator-list &rArr; indicator, value, tail</h3>
<p>Used since <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_getf.htm">getf</a> can’t distinguish an absent property from <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Returns on the first key found.</p>
<pre><code>(get-properties plist &#39;(:x :y)) ;&rArr; :X, 10, (:X 10 :Y 20)</code></pre>
<h3 id="alexandriaplist-alist-plist"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-plist_002dalist">alexandria:plist-alist</a> plist</h3>
<h3 id="alexandriaplist-hash-table-plist-rest-hash-table-initargs"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-plist_002dhash_002dtable">alexandria:plist-hash-table</a> plist &amp;rest hash-table-initargs</h3>
<h3 id="alexandriaremove-from-plist-plist-rest-keys"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-remove_002dfrom_002dplist">alexandria:remove-from-plist</a> plist &amp;rest keys</h3>
<h3 id="alexandriaremove-from-plistf-plist-rest-keys"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-remove_002dfrom_002dplistf">alexandria:remove-from-plistf</a> plist &amp;rest keys</h3>
<p>destructive</p>
<h3 id="alexandriadoplist-key-val-plist-optional-values-forms"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-doplist">alexandria:doplist</a> (key val plist &amp;optional values) forms*</h3>
<h2 id="association-list-alist">Association List (alist)</h2>
<h3 id="acons-key-datum-alist-new-alist"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_acons.htm">acons</a> key datum alist &rArr; new-alist</h3>
<p>Append a <em>cons</em> and return a new <em>alist</em>. To modify an <em>alist</em> in place, use <code>push</code>.</p>
<pre><code>(acons :c 3 &#39;((:B . 2) (:A . 1))) ;&rArr; ((:C . 3) (:B . 2) (:A . 1))
(push (cons :c 3) alist)          ;&rArr; ((:C . 3) (:B . 2) (:A . 1))</code></pre>
<h3 id="pairlis-keys-data-optional-alist-new-alist"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_pairli.htm">pairlis</a> keys data &amp;optional alist &rArr; new-alist</h3>
<p>Pair up elements in <em>keys</em> and <em>data</em> lists to make an <em>alist</em>.</p>
<pre><code>(pairlis &#39;(:a :b) &#39;(1 2)) ;&rArr; ((:B . 2) (:A . 1))</code></pre>
<h3 id="assoc-item-alist-key-key-test-test-not-entry"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_assocc.htm">assoc</a> item alist &amp;key key test test-not &rArr; entry</h3>
<p>Return the alist entry whose <em>car</em> satisfies the test, or <em>nil</em>. Functional variants are <code>assoc-if</code> and <code>assoc-if-not</code>. <code>rassoc</code> uses <em>cdr</em> to test.</p>
<pre><code>(assoc :a &#39;((:A . 1) (:B . 2)))         ;&rArr; (:A . 1)
(rassoc 1 &#39;((:A . 1) (:B . 2)))         ;&rArr; (:A . 1)
(assoc-if #&#39;evenp &#39;((1 . :A) (2 . :B))) ;&rArr; (2 . :B)</code></pre>
<h3 id="copy-alist-alist-new-alist"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cp_ali.htm">copy-alist</a> alist &rArr; new-alist</h3>
<p>Copies the <em>cons</em> cells that make up the alist structure.</p>
<h3 id="alexandriaalist-plist-alist"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-alist_002dplist">alexandria:alist-plist</a> alist</h3>
<p>Converts an <em>alist</em> to a <em>plist</em> format.</p>
<pre><code>(alist-plist &#39;((:x . 10) (:y . 20))) ;&rArr; (:x 10 :y 20)</code></pre>
          </div>
        </article>
      </div>

      <aside>
        <div class="section-padding">
          <nav>
<ul>
  <li><a href="#list-structures" class="toc-header">List Structures</a></li>
  <li><a href="#set-functions" class="toc-header">Set Functions</a></li>
  <li><a href="#alexandriasetp-object-key-test-key-boolean">setp</a></li>
  <li><a href="#subsetp-list1-list2-key-key-test-test-not-boolean">subsetp</a></li>
  <li><a href="#alexandriaset-equal-list1-list2-key-test-key-boolean">set-equal</a></li>
  <li><a href="#member-item-list-key-key-test-test-not-tail">member</a></li>
  <li><a href="#adjoin-item-list-key-key-test-test-not-new-list">adjoin</a></li>
  <li><a href="#union-list1-list2-key-key-test-test-not-result-list">union</a></li>
  <li><a href="#intersection-list1-list2-key-key-test-test-not-result-list">intersection</a></li>
  <li><a href="#set-difference-list1-list2-key-key-test-test-not-result-list">set-difference</a></li>
  <li><a href="#set-exclusive-or-list1-list2-key-key-test-test-not-result-list">set-exclusive-or</a></li>
  <li><a href="#tree-functions" class="toc-header">Tree Functions</a></li>
  <li><a href="#tree-equal">tree-equal</a></li>
  <li><a href="#copy-tree-tree-new-tree">copy-tree</a></li>
  <li><a href="#subst-new-old-tree-key-key-test-test-not-new-tree">subst</a></li>
  <li><a href="#sublis-alist-tree-key-key-test-test-not-new-tree">sublis</a></li>
  <li><a href="#alexandriaflatten-tree-list">flatten</a></li>
  <li><a href="#alexandriacircular-tree-p-object-boolean">circular-tree-p</a></li>
  <li><a href="#property-list-plist" class="toc-header">Property List (plist)</a></li>
  <li><a href="#getf-plist-indicator-optional-default-value">getf</a></li>
  <li><a href="#remf-place-indicator-boolean">remf</a></li>
  <li><a href="#get-properties-plist-indicator-list-indicator-value-tail">get-properties</a></li>
  <li><a href="#alexandriaplist-alist-plist">plist-alist</a></li>
  <li><a href="#alexandriaplist-hash-table-plist-rest-hash-table-initargs">plist-hash-table</a></li>
  <li><a href="#alexandriaremove-from-plist-plist-rest-keys">remove-from-plist</a></li>
  <li><a href="#alexandriaremove-from-plistf-plist-rest-keys">remove-from-plistf</a></li>
  <li><a href="#alexandriadoplist-key-val-plist-optional-values-forms">doplist</a></li>
  <li><a href="#association-list-alist" class="toc-header">Association List (alist)</a></li>
  <li><a href="#acons-key-datum-alist-new-alist">acons</a></li>
  <li><a href="#pairlis-keys-data-optional-alist-new-alist">pairlis</a></li>
  <li><a href="#assoc-item-alist-key-key-test-test-not-entry">assoc</a></li>
  <li><a href="#copy-alist-alist-new-alist">copy-alist</a></li>
  <li><a href="#alexandriaalist-plist-alist">alist-plist</a></li>
</ul>
          </nav>
        </div>
      </aside>
      
      <footer><a href="http://minispec.org">Common Lisp Minispec</a> <a href="https://github.com/lamberta/minispec">&#60;https://github.com/lamberta/minispec&#62;</a></footer>
    </div>

    <script src="./include/jquery.js"></script>
    <script src="./include/typeahead.js"></script>
    <script src="./include/highlight-lisp.js"></script>
    <script src="./include/init.js"></script>
  </body>
</html>
