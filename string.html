<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CL MiniSpec: String</title>
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="shortcut icon" href="./include/fav.png">-->
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata">
    <link rel="stylesheet" href="./include/highlight-lisp.css">
    <link rel="stylesheet" href="./include/style.css">
    <meta name="description" content="">
  </head>
  <body>
    <div>

      <header>
        <div class="section-padding">
<nav id="navbar">
  <h1><a href="./index.html" class="brand">Common Lisp MiniSpec</a></h1>
  <ul>
    <li><a href="#"><span class="caret">&#x25BC;</span>Symbols</a>
      <ul>
        <li><a href="./symbol.html">Overview</a></li>
        <li><a href="./symbol.html#variables">Variable</a></li>
        <li><a href="./symbol.html#functions">Function</a></li>
        <li><a href="./symbol.html#macros">Macro</a></li>
        <li><a href="./package.html#symbols">Symbol</a></li>
        <li><a href="./package.html#packages">Package</a></li>
        <li><a href="#">System</a></li>
      </ul>
    </li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Collections</a>
      <ul>
        <li><a href="./list.html">List</a></li>
        <li><a href="./list-structure.html#set-functions">Set Functions</a></li>
        <li><a href="./list-structure.html#tree-functions">Tree Functions</a></li>
        <li><a href="./list-structure.html#association-list-alist">Association List</a></li>
        <li><a href="./list-structure.html#property-list-plist">Property List</a></li>
        <li><a href="./array.html">Array</a></li>
        <li><a href="./vector.html">Vector</a></li>
        <li><a href="./string.html">String</a></li>
        <li><a href="./hash-table.html">Hash Table</a></li>
        <li><a href="./structure.html">Struct</a></li>
        <li><a href="./object-system.html">Object System</a></li>
      </ul>
    </li>
    <li><a href="./math.html">Math</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Iteration</a>
      <ul>
        <li><a href="./iteration.html">Iteration</a></li>
        <li><a href="./loop-iterate.html">Loop/Iterate</a></li>
      </ul>
    </li>
    <li><a href="./control.html">Control</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>I/O</a>
      <ul>
        <li><a href="./stream.html">Stream</a></li>
        <li><a href="./read.html">Read</a></li>
        <li><a href="./print.html">Print</a></li>
        <li><a href="./print.html#format">Format</a></li>
        <li><a href="./file.html">File</a></li>
        <li><a href="./file.html#pathnames">Pathname</a></li>
      </ul>
    </li>
    <li><a href="./types.html">Types</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>More</a>
      <ul>
        <li><a href="./comparison.html">Comparison</a></li>
        <li><a href="./composition.html">Composition</a></li>
        <li><a href="./compile.html">Compiler</a></li>
        <li><a href="./time.html">Time</a></li>
        <li><a href="./regular-expression.html">Regular Expressions</a></li>
      </ul>
    </li>
    <li><form><input type="search" placeholder="symbol"></input></form></li>
  </ul>
</nav>
        </div>
      </header>
      
      <div class="article-wrapper">
        <article>
          <div class="section-padding">
<h1 id="strings">Strings</h1>
<p>Inherits: <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_vector.htm">vector</a> &rArr; <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_array.htm">array</a> &rArr; <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_seq.htm">sequence</a> &rArr; <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a></p>
<p>A string is a specialized vector (one-dimensional array) whose elements are characters.</p>
<ul>
<li><a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node164.html">CLtL2</a></li>
<li><a href="http://www.gigamonkeys.com/book/numbers-characters-and-strings.html">PCL: Ch 10. Numbers, Characters, and Strings</a></li>
<li><a href="http://www.lispworks.com/documentation/HyperSpec/Body/c_string.htm">HyperSpec: Strings Dictionary</a></li>
</ul>
<h2 id="create">Create</h2>
<h3 id="string-x-string"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_string.htm">string</a> x &rArr; string</h3>
<p>Convert <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_symbol.htm">symbol</a>, <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_kwd.htm">keyword</a>, or <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_ch.htm">character</a> to a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_string.htm">string</a>.</p>
<pre><code>(string :hello) ;&rArr; &quot;hello&quot;</code></pre>
<h3 id="make-string-size-key-initial-element-element-type-string"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_stg.htm">make-string</a> size &amp;key initial-element element-type &rArr; string</h3>
<p>Return a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_smp_st.htm">simple-string</a> of length <em>size</em>.</p>
<pre><code>(make-string 10 :initial-element #\5) ;&rArr; &quot;5555555555&quot;</code></pre>
<h3 id="parse-integer-str-key-start-end-radix-junk-allowed-int-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_parse_.htm">parse-integer</a> str &amp;key start end radix junk-allowed &rArr; int, idx</h3>
<p>Parses an <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_intege.htm">integer</a> in the specified <em>:radix</em>.</p>
<pre><code>(parse-integer &quot;24h&quot; :junk-allowed t) ;&rArr; 24, 2</code></pre>
<h3 id="make-array-dims-key-type-initial-element-initial-contents-adjustable-fill-pointer-displaced-to-displaced-index-offset-new-array"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_ar.htm">make-array</a> dims &amp;key type initial-element initial-contents adjustable fill-pointer displaced-to displaced-index-offset &rArr; new-array</h3>
<pre><code>(make-array &#39;(2 3)) ;&rArr; #2A((0 0 0) (0 0 0))
(make-array 5 :fill-pointer 0 :adjustable t :element-type &#39;character) ;&rArr; &quot;&quot;</code></pre>
<h3 id="adjust-array-array-new-dims-key-type-initial-element-initial-contents-fill-pointer-displaced-to-displaced-index-offset-adjusted-array"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_adjust.htm">adjust-array</a> array new-dims &amp;key type initial-element initial-contents fill-pointer displaced-to displaced-index-offset &rArr; adjusted-array</h3>
<h3 id="alexandriacopy-array-array-key-element-type-fill-pointer-adjustable-new-array"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-copy_002darray">alexandria:copy-array</a> array &amp;key element-type fill-pointer adjustable &rArr; new-array</h3>
<p>Returns an undisplaced copy of <em>array</em>, with same fill-pointer and adjustability as the original.</p>
<h2 id="select">Select</h2>
<h3 id="char-str-idx-character"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_char_.htm">char</a> str idx &rArr; character</h3>
<p>Specialized element accessor for type <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_string.htm">string</a>. Is <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_setf.htm">setf</a>able.</p>
<pre><code>(char &quot;hello&quot; 1) ;&rArr; #\e
(elt &quot;hello&quot; 1)  ;&rArr; #\e</code></pre>
<h3 id="aref-array-rest-subscripts-element"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_aref.htm">aref</a> array &amp;rest subscripts &rArr; element</h3>
<p>Access array elements. Related: <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_svref.htm">svref</a> —Access index of a simple vector.</p>
<pre><code>(setf a (make-array &#39;(2 2) :initial-contents &#39;((1 2) (3 4))))
(aref a 1 1) ;&rArr; 4
(setf (aref a 0 1) 99) ; a &rArr; #2A((1 99) (3 4))</code></pre>
<h3 id="elt-seq-idx-element"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_elt.htm">elt</a> seq idx &rArr; element</h3>
<p>Related: <code>nth</code>, <code>nthcdr</code>, <code>car</code>, <code>cdr</code>, <code>first</code> … <code>tenth</code></p>
<pre><code>(setf seq &#39;(a b c))
(elt seq 1)             ;&rArr; B
(setf (elt seq 1) &quot;hi&quot;) ; seq &rArr; (A &quot;hi&quot; C)</code></pre>
<h3 id="alexandriarandom-elt"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-random_002delt">alexandria:random-elt</a></h3>
<p>Return a random element from a sequence.</p>
<h3 id="length-seq-n"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_length.htm">length</a> seq &rArr; n</h3>
<pre><code>(length &#39;(a b c)) ;&rArr; 3
(length &quot;hello&quot;)  ;&rArr; 5</code></pre>
<h3 id="find-item-seq-key-from-end-test-test-not-start-end-key-element"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find</a> item seq &amp;key from-end test test-not start end key &rArr; element</h3>
<p>If the sequence <em>seq</em> contains an element satisfying <em>test</em>, then the leftmost such element is returned; otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> is returned. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find-if-not</a>.</p>
<pre><code>(find 3 &#39;(1 2 3 4 5))                            ;&rArr; 3
(find-if #&#39;oddp &#39;(1 2 3 4 5) :end 3 :from-end t) ;&rArr; 3</code></pre>
<h3 id="position-item-seq-key-from-end-test-test-not-start-end-key-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_pos_p.htm">position</a> item seq &amp;key from-end test test-not start end key &rArr; idx</h3>
<p>Return the first index position of an item in the sequence, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>.</p>
<pre><code>(position #\a &quot;baobab&quot; :from-end t)                         ;&rArr; 4
(position-if #&#39;oddp &#39;((1) (2) (3) (4)) :start 1 :key #&#39;car) ;&rArr; 2</code></pre>
<h3 id="count-item-seq-key-from-end-start-end-key-test-test-not-n"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_countc.htm">count</a> item seq &amp;key from-end start end key test test-not &rArr; n</h3>
<p>The number of elements in the specified subsequence of <em>seq</em>. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_countc.htm">count-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_countc.htm">count-if-not</a>.</p>
<pre><code>(count &#39;a &#39;(a b c a))      ;&rArr; 2
(count-if #&#39;oddp &#39;(1 2 3)) ;&rArr; 2</code></pre>
<h3 id="cl-utilitiesextremum-seq-fn-key-key-start-0-end-smallest-element"><a href="http://common-lisp.net/project/cl-utilities/doc/extremum.html">cl-utilities:extremum</a> seq fn &amp;key key (start 0) end &rArr; smallest-element</h3>
<p>Returns first element of <em>sequence</em> if it were ordered by <code>sort</code> using the predicate <em>fn</em>. <code>extrema</code> is similar but returns a list of values since there may be more than one extremum determined by the predicate. <code>n-most-extreme</code> returns a list of <em>n</em> values of a sorted sequence. <a href="http://common-lisp.net/project/cl-utilities/doc/extremum.html">ref</a></p>
<pre><code>(extremum &#39;(1 2 9 7 3 2) #&#39;&gt;)         ;&rArr; 9
(extrema &#39;(1 2 9 7 3 2) #&#39;&gt;)          ;&rArr; (9)
(n-most-extreme 3 &#39;(1 2 9 7 3 2) #&#39;&gt;) ;&rArr; (9 7 3)</code></pre>
<h3 id="subseq-seq-start-optional-end-sub-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_subseq.htm">subseq</a> seq start &amp;optional end &rArr; sub-seq</h3>
<p>Returns the sub-sequence of <em>seq</em> specified by <em>start</em> and <em>end</em>.</p>
<pre><code>(setf str &quot;hello&quot;)
(subseq str 2 4) ;&rArr; &quot;ll&quot;
(setf (subseq str 2 4) &quot;ad&quot;) ; str &rArr; &quot;heado&quot;</code></pre>
<h3 id="search-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_search.htm">search</a> seq1 seq2 &amp;key from-end test test-not key start1 start2 end1 end2 &rArr; idx</h3>
<p>Searches sequence <em>seq2</em> for a sub-sequence that matches <em>seq1</em>. Returns its index position.</p>
<pre><code>(search &#39;(c d) &#39;(a b c d)) ;&rArr; 2
(search &quot;bar&quot; &quot;foobarbaz&quot;) ;&rArr; 3</code></pre>
<h3 id="mismatch-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mismat.htm">mismatch</a> seq1 seq2 &amp;key from-end test test-not key start1 start2 end1 end2 &rArr; idx</h3>
<p>Return the index position where two sequences diverge.</p>
<pre><code>(mismatch &quot;foobarbaz&quot; &quot;foom&quot;) ;&rArr; 3</code></pre>
<h2 id="modify">Modify</h2>
<h3 id="string-trim-chars-str-new-str"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_tr.htm">string-trim</a> chars str &rArr; new-str</h3>
<p>Returns a substring of <em>str</em>, with all characters in <em>chars</em> stripped off the beginning and end.</p>
<pre><code>(string-trim &quot;abc&quot; &quot;abcaakaaakabcaaa&quot;) ;&rArr; &quot;kaaak&quot;
(string-trim &#39;(#\Space #\Tab #\Newline) &quot; garbanzo beans &quot;) ;&rArr; &quot;garbanzo beans&quot;
(string-trim &quot; (*)&quot; &quot; ( *three (silly) words* ) &quot;) ;&rArr; &quot;three (silly) words&quot;</code></pre>
<h3 id="string-left-trim-chars-str-new-str"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_tr.htm">string-left-trim</a> chars str &rArr; new-str</h3>
<pre><code>(string-left-trim &quot;abc&quot; &quot;labcabcabc&quot;) ;&rArr; &quot;labcabcabc&quot;
(string-left-trim &quot; (*)&quot; &quot; ( *three (silly) words* ) &quot;) ;&rArr; &quot;three (silly) words* ) &quot;</code></pre>
<h3 id="string-right-trim-chars-str-new-str"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_tr.htm">string-right-trim</a> chars str &rArr; new-str</h3>
<pre><code>(string-right-trim &quot; (*)&quot; &quot; ( *three (silly) words* ) &quot;) ;&rArr; &quot; ( *three (silly) words&quot;</code></pre>
<h3 id="string-upcase-str-key-start-end-new-str"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm">string-upcase</a> str &amp;key start end &rArr; new-str</h3>
<p>Also <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm">nstring-upcase</a></p>
<h3 id="string-downcase-str-key-start-end-new-str"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm">string-downcase</a> str &amp;key start end &rArr; new-str</h3>
<p>Also <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm">nstring-downcase</a></p>
<h3 id="string-capitalize-str-key-start-end-new-str"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm">string-capitalize</a> str &amp;key start end &rArr; new-str</h3>
<p>Also <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm">nstring-capitalize</a></p>
<h3 id="vector-push-new-element-vector-index"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vec_ps.htm">vector-push</a> new-element vector &rArr; index</h3>
<pre><code>(setf v (make-array 2 :fill-pointer 0)) ;&rArr; #()
(vector-push &#39;a v)                      ;&rArr; 0   [v &rArr; #(A)]
(vector-push &#39;b v)                      ;&rArr; 1   [v &rArr; #(A B)]
(vector-push &#39;c v)                      ;&rArr; NIL [v &rArr; #(A B)]</code></pre>
<h3 id="vector-push-extend-new-element-vector-extension-index"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vec_ps.htm">vector-push-extend</a> new-element vector [extension] &rArr; index</h3>
<pre><code>(setf v (make-array 2 :fill-pointer 0 :adjustable t) ;&rArr; #()
(vector-push &#39;a v)                      ;&rArr; 0   [v &rArr; #(A)]
(vector-push &#39;b v)                      ;&rArr; 1   [v &rArr; #(A B)]
(vector-push-extend &#39;c v)               ;&rArr; 2   [v &rArr; #(A B C)]</code></pre>
<h3 id="vector-pop"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vec_po.htm">vector-pop</a></h3>
<p>Decreases the fill pointer of vector by one, and retrieves the element of vector that is designated by the new fill pointer.</p>
<h3 id="concatenate-result-type-rest-seqs-result-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_concat.htm">concatenate</a> result-type &amp;rest seqs… &rArr; result-seq</h3>
<pre><code>(concatenate &#39;list &#39;(a b) &#39;(c d)) ;&rArr; (A B C D)
(concatenate &#39;string &quot;hello&quot; &quot;world&quot;) ;&rArr; &quot;helloworld&quot;</code></pre>
<h3 id="cl-utilitiessplit-sequence-delimiter-seq-key-count-remove-empty-subseqs-from-end-start-end-test-test-not-key-list-idx"><a href="http://common-lisp.net/project/cl-utilities/doc/split-sequence.html">cl-utilities:split-sequence</a> delimiter seq &amp;key count remove-empty-subseqs from-end start end test test-not key &rArr; list, idx</h3>
<p>Splits sequence into a <em>list</em> of subsequences delimited by objects satisfying the test. Also returns the lenbth of the sequence <em>idx</em>. Functional variants are <a href="http://common-lisp.net/project/cl-utilities/doc/split-sequence.html">cl-utilities:split-sequence-if</a> and <a href="http://common-lisp.net/project/cl-utilities/doc/split-sequence.html">cl-utilities:split-sequence-if-not</a>.</p>
<pre><code>(split-sequence #\Space &quot;hello world&quot;)           ;&rArr; (&quot;hello&quot; &quot;world&quot;), 11
(split-sequence-if #&#39;evenp &#39;(1 1 2 1 3 4 1 3 5)) ;&rArr; ((1 1) (1 3) (1 3 5)), 9</code></pre>
<h3 id="fill-seq-item-key-start-end-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fill.htm">fill</a> seq item &amp;key start end &rArr; seq</h3>
<p>Destructively replaces the elements of <em>seq</em> bounded by <em>:start</em> and <em>:end</em> with <em>item</em>.</p>
<pre><code>(fill &#39;(a b c d) &#39;x :start 1 :end 3) ;&rArr; (A X X D)</code></pre>
<h3 id="replace-seq1-seq2-key-start1-end1-start2-end2-seq1"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_replac.htm">replace</a> seq1 seq2 &amp;key start1 end1 start2 end2 &rArr; seq1</h3>
<p>Destructively replaces the elements of <em>se1</em> bounded by <em>:start1</em> and <em>:end1</em> with the elements of <em>seq2</em> bounded by <em>:start2</em> and <em>:end2</em>.</p>
<pre><code>(replace &quot;abcde&quot; &quot;98765&quot; :start1 1 :end1 3 :start2 3) ;&rArr; &quot;a65de&quot;</code></pre>
<p>To remove an element from a sequence at a given position:</p>
<pre><code>(setf lst &#39;(a b c d e))
(setf i (position &#39;b lst))                 ;&rArr; 1
(replace lst lst :start1 i :start2 (1+ i)) ;&rArr; (A C D E E)
(butlast lst)                              ;&rArr; (A C D E)</code></pre>
<h3 id="substitute-new-old-seq-key-from-end-test-test-not-start-end-count-key"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute</a> new old seq &amp;key from-end test test-not start end count key</h3>
<p>Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute-if</a>, <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute-if-not</a>. Destructive variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">nsubstitute</a>, <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">nsubstitute-if</a>, and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">nsubstitute-if-not</a>. <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst</a> performs substitutions throughout a <em>tree</em>.</p>
<pre><code>(substitute 10 1 &#39;(1 2 1 3 1 4))      ;&rArr; (10 2 10 3 10 4)
(substitute-if 0 #&#39;oddp &#39;(1 2 3 4 5)) ;&rArr; (0 2 0 4 0)</code></pre>
<h3 id="remove-item-seq-key-from-end-test-test-not-start-end-count-key-result-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove</a> item seq &amp;key from-end test test-not start end count key &rArr; result-seq</h3>
<p>Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove-if-not</a>. The destructive variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">delete</a>, <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">delete-if</a>, and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">delete-if-not</a>. To remove in place, use <a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-removef">alexandria:removef</a> or <a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-deletef">alexandria:deletef</a>.</p>
<pre><code>(remove 4 &#39;(1 2 4 1 3 4 5))           ;&rArr; (1 2 1 3 5)
(remove-if #&#39;oddp &#39;(1 2 4 1 3 4 5))   ;&rArr; (2 4 4)
(remove-if-not #&#39;oddp &#39;(1 2 1 3 4 5)) ;&rArr; (1 1 3 5)</code></pre>
<h3 id="remove-duplicates-seq-key-from-end-test-test-not-start-end-key"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_dup.htm">remove-duplicates</a> seq &amp;key from-end test test-not start end key</h3>
<p>Destructive variant is <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_dup.htm">delete-duplicates</a>.</p>
<pre><code>(remove-duplicates &#39;(1 2 1 2 3 1 2 3 4)) ;&rArr; (1 2 3 4)</code></pre>
<h2 id="comparison">Comparison</h2>
<h3 id="string-str1-str2-key-start1-end1-start2-end2-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string=</a> str1 str2 &amp;key start1 end1 start2 end2 &rArr; boolean</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> if the given strings are of the same length and contain the same characters, otherwise return <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Ignore differences in case using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string-equal</a>.</p>
<pre><code>(string= &quot;foo&quot; &quot;foo&quot;) ;&rArr; T
(string= &quot;foo&quot; &quot;Foo&quot;) ;&rArr; NIL
(string= &quot;abcd&quot; &quot;01234abcd9012&quot; :start2 5 :end2 9) ;&rArr; T
(string-equal &quot;foo&quot; &quot;Foo&quot;) ;&rArr; T</code></pre>
<h3 id="string-str1-str2-key-start1-end1-start2-end2-mismatch-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string/=</a> str1 str2 &amp;key start1 end1 start2 end2 &rArr; mismatch-idx</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> if the given strings are different, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Ignore differences in case using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string-not-equal</a>.</p>
<pre><code>(string-not-equal &quot;AAAA&quot; &quot;aaaA&quot;) ;&rArr; NIL</code></pre>
<h3 id="string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-1"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string&lt;</a> str1 str2 &amp;key start1 end1 start2 end2 &rArr; mismatch-idx</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> if <em>str1</em> is less than <em>str2</em>, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Ignore differences in case using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string-lessp</a>.</p>
<pre><code>(string&lt; &quot;aaaa&quot; &quot;aaab&quot;) ;&rArr; 3
(string-lessp &quot;012AAAA789&quot; &quot;01aaab6&quot; :start1 3 :end1 7 :start2 2 :end2 6) ;&rArr; 6</code></pre>
<h3 id="string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-2"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string&gt;</a> str1 str2 &amp;key start1 end1 start2 end2 &rArr; mismatch-idx</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> if <em>str1</em> is greater than <em>str2</em>, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Ignore differences in case using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string-greaterp</a>.</p>
<h3 id="string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-3"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string&lt;=</a> str1 str2 &amp;key start1 end1 start2 end2 &rArr; mismatch-idx</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> if <em>str1</em> is less than or equal to <em>str2</em>, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Ignore differences in case using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string-not-greaterp</a>.</p>
<pre><code>(string&gt;= &quot;aaaaa&quot; &quot;aaaa&quot;) ;&rArr; 4
(string-not-greaterp &quot;Abcde&quot; &quot;abcdE&quot;) ;&rArr; 5</code></pre>
<h3 id="string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-4"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string&gt;=</a> str1 str2 &amp;key start1 end1 start2 end2 &rArr; mismatch-idx</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> if <em>str1</em> is greater than or equal to <em>str2</em>, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Ignore differences in case using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm">string-not-lessp</a>.</p>
<h2 id="predicates">Predicates</h2>
<h3 id="stringp-obj-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stgp.htm">stringp</a> obj &rArr; boolean</h3>
<p>Test if an object is a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_string.htm">string</a>.</p>
<h3 id="some-fn-seq-rest-seqs-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">some</a> fn seq &amp;rest seqs* &rArr; result</h3>
<p>Returns the first non-<a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> value which is returned by an invocation of the predicate <em>fn</em>.</p>
<pre><code>(some #&#39;evenp &#39;(1 2 3 4))  ;&rArr; T
(some #&#39;1+ &#39;(10 20 30 40)) ;&rArr; 11
(some #&#39;numberp &#39;(a b c))  ;&rArr; NIL</code></pre>
<h3 id="every-fn-seq-rest-seqs-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">every</a> fn seq &amp;rest seqs* &rArr; boolean</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> as soon as any invocation of the predicate <em>fn</em> returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>.</p>
<pre><code>(every #&#39;numberp &#39;(1 2 3 4)) ;&rArr; T
(every #&#39;evenp &#39;(1 2 3 4))   ;&rArr; NIL</code></pre>
<h3 id="notevery-fn-seq-rest-seqs-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">notevery</a> fn seq &amp;rest seqs* &rArr; boolean</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> as soon as any invocation of predicate <em>fn</em> returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>.</p>
<pre><code>(notevery #&#39;numberp &#39;(1 2 3 4)) ;&rArr; NIL
(notevery #&#39;evenp &#39;(1 2 3 4))   ;&rArr; T</code></pre>
<h3 id="notany-fn-seq-rest-seqs-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">notany</a> fn seq &amp;rest seqs* &rArr; boolean</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> as soon as any invocation of predicate <em>fn</em> returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a>.</p>
<pre><code>(notany #&#39;numberp &#39;(1 2 3 4)) ;&rArr; NIL
(notany #&#39;evenp &#39;(1 2 3 4))   ;&rArr; NIL</code></pre>
          </div>
        </article>
      </div>

      <aside>
        <div class="section-padding">
          <nav>
<ul>
  <li><a href="#strings" class="toc-header">Strings</a></li>
  <li><a href="#create" class="toc-header">Create</a></li>
  <li><a href="#string-x-string">string</a></li>
  <li><a href="#make-string-size-key-initial-element-element-type-string">make-string</a></li>
  <li><a href="#parse-integer-str-key-start-end-radix-junk-allowed-int-idx">parse-integer</a></li>
  <li><a href="#make-array-dims-key-type-initial-element-initial-contents-adjustable-fill-pointer-displaced-to-displaced-index-offset-new-array">make-array</a></li>
  <li><a href="#adjust-array-array-new-dims-key-type-initial-element-initial-contents-fill-pointer-displaced-to-displaced-index-offset-adjusted-array">adjust-array</a></li>
  <li><a href="#alexandriacopy-array-array-key-element-type-fill-pointer-adjustable-new-array">copy-array</a></li>
  <li><a href="#select" class="toc-header">Select</a></li>
  <li><a href="#char-str-idx-character">char</a></li>
  <li><a href="#aref-array-rest-subscripts-element">aref</a></li>
  <li><a href="#elt-seq-idx-element">elt</a></li>
  <li><a href="#alexandriarandom-elt">random-elt</a></li>
  <li><a href="#length-seq-n">length</a></li>
  <li><a href="#find-item-seq-key-from-end-test-test-not-start-end-key-element">find</a></li>
  <li><a href="#position-item-seq-key-from-end-test-test-not-start-end-key-idx">position</a></li>
  <li><a href="#count-item-seq-key-from-end-start-end-key-test-test-not-n">count</a></li>
  <li><a href="#cl-utilitiesextremum-seq-fn-key-key-start-0-end-smallest-element">extremum</a></li>
  <li><a href="#subseq-seq-start-optional-end-sub-seq">subseq</a></li>
  <li><a href="#search-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx">search</a></li>
  <li><a href="#mismatch-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx">mismatch</a></li>
  <li><a href="#modify" class="toc-header">Modify</a></li>
  <li><a href="#string-trim-chars-str-new-str">string-trim</a></li>
  <li><a href="#string-left-trim-chars-str-new-str">string-left-trim</a></li>
  <li><a href="#string-right-trim-chars-str-new-str">string-right-trim</a></li>
  <li><a href="#string-upcase-str-key-start-end-new-str">string-upcase</a></li>
  <li><a href="#string-downcase-str-key-start-end-new-str">string-downcase</a></li>
  <li><a href="#string-capitalize-str-key-start-end-new-str">string-capitalize</a></li>
  <li><a href="#vector-push-new-element-vector-index">vector-push</a></li>
  <li><a href="#vector-push-extend-new-element-vector-extension-index">vector-push-extend</a></li>
  <li><a href="#vector-pop">vector-pop</a></li>
  <li><a href="#concatenate-result-type-rest-seqs-result-seq">concatenate</a></li>
  <li><a href="#cl-utilitiessplit-sequence-delimiter-seq-key-count-remove-empty-subseqs-from-end-start-end-test-test-not-key-list-idx">split-sequence</a></li>
  <li><a href="#fill-seq-item-key-start-end-seq">fill</a></li>
  <li><a href="#replace-seq1-seq2-key-start1-end1-start2-end2-seq1">replace</a></li>
  <li><a href="#substitute-new-old-seq-key-from-end-test-test-not-start-end-count-key">substitute</a></li>
  <li><a href="#remove-item-seq-key-from-end-test-test-not-start-end-count-key-result-seq">remove</a></li>
  <li><a href="#remove-duplicates-seq-key-from-end-test-test-not-start-end-key">remove-duplicates</a></li>
  <li><a href="#comparison" class="toc-header">Comparison</a></li>
  <li><a href="#string-str1-str2-key-start1-end1-start2-end2-boolean">string=</a></li>
  <li><a href="#string-str1-str2-key-start1-end1-start2-end2-mismatch-idx">string/=</a></li>
  <li><a href="#string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-1">string<</a></li>
  <li><a href="#string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-2">string></a></li>
  <li><a href="#string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-3">string<=</a></li>
  <li><a href="#string-str1-str2-key-start1-end1-start2-end2-mismatch-idx-4">string>=</a></li>
  <li><a href="#predicates" class="toc-header">Predicates</a></li>
  <li><a href="#stringp-obj-boolean">stringp</a></li>
  <li><a href="#some-fn-seq-rest-seqs-result">some</a></li>
  <li><a href="#every-fn-seq-rest-seqs-boolean">every</a></li>
  <li><a href="#notevery-fn-seq-rest-seqs-boolean">notevery</a></li>
  <li><a href="#notany-fn-seq-rest-seqs-boolean">notany</a></li>
</ul>
          </nav>
        </div>
      </aside>
      
      <footer><a href="http://minispec.org">Common Lisp Minispec</a> <a href="https://github.com/lamberta/minispec">&#60;https://github.com/lamberta/minispec&#62;</a></footer>
    </div>

    <script src="./include/jquery.js"></script>
    <script src="./include/typeahead.js"></script>
    <script src="./include/highlight-lisp.js"></script>
    <script src="./include/init.js"></script>
  </body>
</html>
