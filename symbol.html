<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CL MiniSpec: Symbol</title>
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="shortcut icon" href="./include/fav.png">-->
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata">
    <link rel="stylesheet" href="./include/highlight-lisp.css">
    <link rel="stylesheet" href="./include/style.css">
    <meta name="description" content="">
  </head>
  <body>
    <div>

      <header>
        <div class="section-padding">
<nav id="navbar">
  <h1><a href="./index.html" class="brand">Common Lisp MiniSpec</a></h1>
  <ul>
    <li><a href="#"><span class="caret">&#x25BC;</span>Symbols</a>
      <ul>
        <li><a href="./symbol.html">Overview</a></li>
        <li><a href="./symbol.html#variables">Variable</a></li>
        <li><a href="./symbol.html#functions">Function</a></li>
        <li><a href="./symbol.html#macros">Macro</a></li>
        <li><a href="./package.html#symbols">Symbol</a></li>
        <li><a href="./package.html#packages">Package</a></li>
        <li><a href="#">System</a></li>
      </ul>
    </li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Collections</a>
      <ul>
        <li><a href="./list.html">List</a></li>
        <li><a href="./list-structure.html#set-functions">Set Functions</a></li>
        <li><a href="./list-structure.html#tree-functions">Tree Functions</a></li>
        <li><a href="./list-structure.html#association-list-alist">Association List</a></li>
        <li><a href="./list-structure.html#property-list-plist">Property List</a></li>
        <li><a href="./array.html">Array</a></li>
        <li><a href="./vector.html">Vector</a></li>
        <li><a href="./string.html">String</a></li>
        <li><a href="./hash-table.html">Hash Table</a></li>
        <li><a href="./structure.html">Struct</a></li>
        <li><a href="./object-system.html">Object System</a></li>
      </ul>
    </li>
    <li><a href="./math.html">Math</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Iteration</a>
      <ul>
        <li><a href="./iteration.html">Iteration</a></li>
        <li><a href="./loop-iterate.html">Loop/Iterate</a></li>
      </ul>
    </li>
    <li><a href="./control.html">Control</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>I/O</a>
      <ul>
        <li><a href="./stream.html">Stream</a></li>
        <li><a href="./read.html">Read</a></li>
        <li><a href="./print.html">Print</a></li>
        <li><a href="./print.html#format">Format</a></li>
        <li><a href="./file.html">File</a></li>
        <li><a href="./file.html#pathnames">Pathname</a></li>
      </ul>
    </li>
    <li><a href="./types.html">Types</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>More</a>
      <ul>
        <li><a href="./comparison.html">Comparison</a></li>
        <li><a href="./composition.html">Composition</a></li>
        <li><a href="./compile.html">Compiler</a></li>
        <li><a href="./time.html">Time</a></li>
        <li><a href="./regular-expression.html">Regular Expressions</a></li>
      </ul>
    </li>
    <li><form><input type="search" placeholder="symbol"></input></form></li>
  </ul>
</nav>
        </div>
      </header>
      
      <div class="article-wrapper">
        <article>
          <div class="section-padding">
<h1 id="symbol-definition">Symbol Definition</h1>
<h2 id="style-guides">Style Guides</h2>
<ul>
<li><a href="http://www.cliki.net/Naming%20conventions">Naming Conventions</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml">Google Style Guide</a></li>
</ul>
<h2 id="variables">Variables</h2>
<h3 id="defparameter-name-value-doc-string-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defpar.htm">defparameter</a> name value [doc-string] &rArr; name</h3>
<p>Unconditionally assign <em>value</em> to a global dynamic variable. The convention for naming a (global) special variable is <code>*name*</code>.</p>
<pre><code>(defparameter *x* 1) ;&rArr; *X*</code></pre>
<h3 id="defvar-name-value-doc-string-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defpar.htm">defvar</a> name [value doc-string] &rArr; name</h3>
<p>Unless bound already, assign <em>value</em> to a global dynamic variable.</p>
<pre><code>(defvar *x* &#39;a) ;&rArr; *X*
(defvar *x* &#39;b)
*x*             ;&rArr; A</code></pre>
<h3 id="defconstant-name-value-doc-string-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcon.htm">defconstant</a> name value [doc-string] &rArr; name</h3>
<p>Assign <em>value</em> to a global constant variable. A constant can be redefined by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcon.htm">defconstant</a>. The convention for naming a constant is <code>+name+</code>.</p>
<pre><code>(defconstant +x+ &#39;a) ;&rArr; +X+
(setf +x+ &#39;b)        ;&rArr; [error]</code></pre>
<h3 id="setf-place-value-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_setf.htm">setf</a> {place value}* &rArr; result</h3>
<p>Sets the value of <em>place</em> to <em>value</em>. Multiple pairs are set sequentially, use <code>psetf</code> to set in parallel. <code>setf</code> works with symbols and forms, and is preferred, while <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_setq.htm">setq</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_psetq.htm">psetq</a> can only set symbols.</p>
<h3 id="let-var-var-value-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm">let</a> ({var | (var [value])}*) forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with <em>vars</em> lexically bound (or <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">NIL</a>) to values, assigned in parallel. Use <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm">let*</a> to assign sequentially.</p>
<pre><code>(let ((x 1))
  (list x))       ;&rArr; (1)

(let* ((x 1)
       (y (+1 x)))
  (list x y))      ;&rArr; (1 2)</code></pre>
<h3 id="multiple-value-bind-vars-values-form-body-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_multip.htm">multiple-value-bind</a> (vars*) values-form body-forms* &rArr; result*</h3>
<p>Evaluate <em>body-forms</em> with <em>vars</em> lexically bound to the return values of <em>values-form</em>. Return values of <em>body-forms</em>.</p>
<pre><code>(multiple-value-bind (q r) (floor 7.5)
  (list q r))                          ;&rArr; (7 0.5)</code></pre>
<h3 id="destructuring-bind-lambda-list-expression-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_destru.htm">destructuring-bind</a> lambda-list expression forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with variables from tree <em>lambda-list</em> bound to corresponding elements of tree <em>expression</em>, and return their values.</p>
<ul>
<li><a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_de.htm">HyperSpec: Destructuring Lambda Lists</a></li>
<li><a href="http://www.gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html#destructuring-bind">PCL: Destructuring-Bind</a></li>
</ul>
<pre><code>(destructuring-bind (a b c) (list 1 (list 2 20) 3)
  (list a b c))       ;&rArr; (1 (2 20) 3)

(destructuring-bind (a (b &amp;optional c) d) (list 1 (list 2) 3)
  (list a b c d))     ;&rArr; (1 2 NIL 3)

(destructuring-bind (&amp;whole whole &amp;key a b c) (list :c 3 :b 2 :a 1)
  (list a b c whole)) ;&rArr; (1 2 3 (:C 3 :B 2 :A 1))</code></pre>
<h3 id="shiftf-place-newvalue-first-value"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_shiftf.htm">shiftf</a> place* newvalue &rArr; first-value</h3>
<p>Store <em>newvalue</em> in rightmost <em>place</em>, shifting values of places left, returning first <em>place</em>.</p>
<pre><code>(setf a :a b :b)
(shiftf a b :c)  ;&rArr; :A
(list a b)       ;&rArr; (:B :C)</code></pre>
<h3 id="rotatef-places-nil"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_rotate.htm">rotatef</a> places* &rArr; nil</h3>
<p>Rotate values of <em>places</em> left, the first becoming new last place’s value.</p>
<pre><code>(setf a :a b :b c :c)
(rotatef a b c)       ;&rArr; NIL
(list a b c)          ;&rArr; (:B :C :A)</code></pre>
<h3 id="makunbound-symbol-symbol"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_makunb.htm">makunbound</a> symbol &rArr; symbol</h3>
<p>Makes <em>symbol</em> unbound, regardless of whether it was previously bound.</p>
<pre><code>(setf a 1)
(boundp &#39;a)     ;&rArr; T
(makunbound &#39;a) ;&rArr; A
(boundp &#39;a)     ;&rArr; NIL</code></pre>
<h2 id="advanced">Advanced</h2>
<h3 id="psetf-place-value-nil"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_setf_.htm">psetf</a> {place value}* &rArr; nil</h3>
<h3 id="setq-place-value-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_setq.htm">setq</a> {place value}* &rArr; result</h3>
<h3 id="psetq-place-value-nil"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_psetq.htm">psetq</a> {place value}* &rArr; nil</h3>
<h3 id="multiple-value-setq-vars-form-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_mult_2.htm">multiple-value-setq</a> (vars) form &rArr; result</h3>
<p>Assign multiple values returned by <em>form</em> to <em>vars</em>.</p>
<pre><code>(multiple-value-setq (a b) (values 1 2))</code></pre>
<h3 id="progv-symbols-values-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_progv.htm">progv</a> symbols values forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with locally established dynamic bindings of <em>symbols</em> to <em>values</em>.</p>
<pre><code>(setf *a* 1)
(progv &#39;(*a*) &#39;(2)
  (print *a*))     ;&rArr; [prints 2]</code></pre>
<h2 id="functions">Functions</h2>
<ul>
<li><a href="http://www.gigamonkeys.com/book/functions.html">PCL: Functions</a></li>
</ul>
<h3 id="defun-name-lambda-list-declare-doc-form-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defun.htm">defun</a> name lambda-list [[declare* | doc]] form* &rArr; name</h3>
<p>Define a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> with a given <em>name</em>, which acts as an implicit <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_block.htm">block</a> when evaluating <em>forms</em>. Optionally <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> type information about the function parameters.</p>
<pre><code>(defun adder (a b)
  (declare (number a b))
  &quot;Sum numbers and return the result.&quot;
  (+ a b))

(adder 3 4) ;&rArr; 7</code></pre>
<h3 id="lambda-lambda-list-declare-doc-form-function"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_lambda.htm">lambda</a> lambda-list [[declare* | doc]] form* &rArr; function</h3>
<p>Return an anonymous <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a>.</p>
<pre><code>(funcall #&#39;(lambda (x) (* x x)) 3) ;&rArr; 9</code></pre>
<h3 id="labels-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">labels</a> ((name lambda-list [[local-declare | local-doc]] local-forms*)*) [declare*] forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with a locally defined function. Functions defined by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">labels</a> are visible within <em>local-forms</em>, functions defined by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">flet</a> are not.</p>
<pre><code>(labels ((adder (a b)
           (+ a b))
         (adder1 (a b)
           (1+ (adder a b))))
  (adder1 4 3))               ;&rArr; 8

(flet ((adder (a b)
         (+ a b)))
  (adder 4 3))                ;&rArr; 7</code></pre>
<h3 id="function-name-function"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> name &rArr; function</h3>
<p>The shorthand notation is <code>#'</code>. Return the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> for <em>name</em>.</p>
<pre><code>(funcall #&#39;list &#39;a &#39;b) ;&rArr; (A B)</code></pre>
<h3 id="funcall-function-args-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_funcal.htm">funcall</a> function args* &rArr; result</h3>
<p>Apply values as arguments to <em>function</em>.</p>
<pre><code>(funcall #&#39;+ 1 2 3) ;&rArr; 6</code></pre>
<h3 id="apply-function-args-arg-list-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_apply.htm">apply</a> function [args*] arg-list &rArr; result</h3>
<p>Apply values as arguments to <em>function</em>, the final one a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a>.</p>
<pre><code>(apply #&#39;+ &#39;(1 2 3))   ;&rArr; 6
(apply #&#39;+ 1 2 &#39;(3 4)) ;&rArr; 10</code></pre>
<h3 id="multiple-value-call-function-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_multip.htm">multiple-value-call</a> function forms* &rArr; result</h3>
<p>Apply all values returned from <em>forms</em> as arguments to <em>function</em>.</p>
<pre><code>(multiple-value-call #&#39;+ (floor 5.5) (floor 4.3)) ;= (+ 5 0.5 4 0.3) &rArr; 9.8</code></pre>
<h3 id="values-objects-objects"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_values.htm">values</a> objects* &rArr; objects*</h3>
<p>Return <em>objects</em> as multiple values. <code>setf</code>able.</p>
<pre><code>(values &#39;a &#39;b)        ;&rArr; A, B
(list (values &#39;a &#39;b)) ;&rArr; (A)

(setf (values a b) (floor 7.5))
(list a b)                             ;&rArr; (7 0.5)</code></pre>
<h3 id="values-list-list-objects"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vals_l.htm">values-list</a> list &rArr; objects*</h3>
<p>Return <em>list</em> elements as multiple values.</p>
<pre><code>(values-list &#39;(A B)) ;&rArr; A, B

(multiple-value-bind (a b) (values-list &#39;(1 2))
  (list a b))  ;&rArr; (1 2)</code></pre>
<h3 id="multiple-value-list-form-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_mult_1.htm">multiple-value-list</a> form &rArr; list</h3>
<p>Evaluates <em>form</em> returning multiple values and returns a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a> containing them.</p>
<pre><code>(multiple-value-list (floor 7.5)) ;&rArr; (7 0.5)</code></pre>
<h3 id="fmakunbound-name-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fmakun.htm">fmakunbound</a> name &rArr; name</h3>
<p>Removes the function or macro definition.</p>
<pre><code>(defun add-some (x) (+ x 19))   ;&rArr; ADD-SOME
(fboundp &#39;add-some)             ;&rArr; T
(flet ((add-some (x) (+ x 37)))
  (fmakunbound &#39;add-some)
  (add-some 1))                 ;&rArr; 38
(fboundp &#39;add-some)             ;&rArr; NIL</code></pre>
<h2 id="advanced-1">Advanced</h2>
<h3 id="flet-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">flet</a> ((name lambda-list [[local-declare | local-doc]] local-forms*)*) [declare*] forms* &rArr; result*</h3>
<h3 id="nth-value-n-form-object"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_nth_va.htm">nth-value</a> n form &rArr; object</h3>
<p>Return the <em>n</em>th value yielded by <em>form</em>, zero-indexed.</p>
<pre><code>(nth-value 0 (values &#39;a &#39;b)) ;&rArr; A
(nth-value 1 (values &#39;a &#39;b)) ;&rArr; B</code></pre>
<h3 id="function-lambda-expression-function-lambda-expression-closure-p-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fn_lam.htm">function-lambda-expression</a> function &rArr; lambda-expression, closure-p, name</h3>
<p>If available, return lambda expression of <em>function</em>, `<a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> if <em>function</em> was defined in an environment without bindings, and name of <em>function</em>.</p>
<pre><code>(function-lambda-expression (funcall #&#39;(lambda (x) #&#39;(lambda () x)) nil)) ;&rArr; NIL, T, NIL</code></pre>
<h3 id="fdefinition-name-definition"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fdefin.htm">fdefinition</a> name &rArr; definition</h3>
<p>Definition of global function foo; <code>setf</code>able.</p>
<pre><code>(fdefinition &#39;list) ;&rArr; #&lt;Compiled-function LIST&gt;</code></pre>
<h2 id="macros">Macros</h2>
<p>The Common Lisp macro facility allows the user to define arbitrary functions that convert certain Lisp forms into different forms before evaluating or compiling them. This is done at the expression level, not at the character-string level as in most other languages. Macros are important in the writing of good code: they make it possible to write code that is clear and elegant at the user level but that is converted to a more complex or more efficient internal form for execution.</p>
<ul>
<li><a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node97.html">CLtL2: Macros</a></li>
<li><a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html">PCL: Macros: Defining Your Own</a></li>
</ul>
<h3 id="defmacro-name-lambda-list-declare-doc-forms-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defmac.htm">defmacro</a> name lambda-list [[declare* | doc]] forms* &rArr; name</h3>
<p>Define a macro with a given <em>name</em>, which acts as an implicit <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_block.htm">block</a> when evaluating <em>forms</em>. <code>define-compiler-macro</code> is similar with a few differences.</p>
<pre><code>(defmacro adder (a b)
  &quot;Sums two numbers and returns the result&quot;
  `(+ ,a ,b))

(adder 4 5) ;&rArr; 9</code></pre>
<h3 id="macrolet-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">macrolet</a> ((name lambda-list [[local-declare | local-doc]] local-forms*)*) [declare*] forms* &rArr; result*</h3>
<p>Defines local macro definitions, using the same format used by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defmac.htm">defmacro</a>.</p>
<pre><code>(macrolet ((adder (a b) `(+ ,a ,b)))
  (adder 4 5))                       ;&rArr; 9</code></pre>
<h3 id="define-symbol-macro-symbol-expansion-symbol"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_1.htm">define-symbol-macro</a> symbol expansion &rArr; symbol</h3>
<p>Defines a macro expansion for <em>symbol</em>. <code>setf</code>able.</p>
<pre><code>(setf a &#39;(1 2 3))
(define-symbol-macro b (car a)) ;&rArr; B
b                               ;&rArr; 1
(setf b 5)
a                               ;&rArr; (5 2 3)
b                               ;&rArr; 5</code></pre>
<h2 id="advanced-2">Advanced</h2>
<h3 id="symbol-macrolet-symbol-expansion-declare-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_symbol.htm">symbol-macrolet</a> ((symbol expansion)*) declare* forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with locally defined symbol macros.</p>
<pre><code>(symbol-macrolet ((x &#39;foo))
  (list x (let ((x &#39;bar)) x))) ;&rArr; (FOO BAR)</code></pre>
<h3 id="define-modify-macro-name-lambda-list-function-doc-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_2.htm">define-modify-macro</a> name lambda-list function [doc] &rArr; name</h3>
<p>Defines a macro to read and write a place.</p>
<pre><code>(define-modify-macro new-incf (&amp;optional (delta 1)) +)
(setf a 1)
(new-incf a) ;&rArr; 2</code></pre>
<h3 id="defsetf-access-fn-update-fn-doc-access-fn"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defset.htm">defsetf</a> access-fn update-fn [doc] &rArr; access-fn</h3>
<p>Specify how to <code>setf</code> a place accessed by function. There is a “short form” and “long form” of <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defset.htm">defsetf</a> as distinguished by the type of arguments.</p>
<pre><code>(defun middle (x)
  (nth (truncate (* (list-length x) 0.5)) x))
(defun set-middle (x val)
  (let ((idx (truncate (* (list-length x) 0.5))))
    (setf (nth idx x) val)))
(defsetf middle set-middle)

(setf a &#39;(a b c))   ;&rArr; (A B C)
(middle a)          ;&rArr; B
(setf (middle a) 2)
a                   ;&rArr; (A 2 C)</code></pre>
<h3 id="get-setf-expansion-place-optional-env-vars-vals-store-vars-writer-form-reader-form"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_get_se.htm">get-setf-expansion</a> place &amp;optional env &rArr; vars, vals, store-vars, writer-form, reader-form</h3>
<p>Returns lists of temporary variables, values, and get and set forms for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_setf.htm">setf</a> to read <em>place</em>.</p>
<pre><code>(defvar x)
(get-setf-expansion &#39;x) ;&rArr; NIL, NIL, (#:G6725), (SETQ X #:G6725), X</code></pre>
<ul>
<li><a href="http://www.lispworks.com/documentation/HyperSpec/Body/05_aab.htm">Setf Expansions</a></li>
</ul>
<h3 id="define-setf-expander-access-fn-lambda-list-declaration-doc-form-access-fn"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_3.htm">define-setf-expander</a> access-fn lambda-list [[declaration* | doc]] form* &rArr; access-fn</h3>
<p>Specifies the means by which <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_setf.htm">setf</a> updates a place that is referenced by <em>access-fn</em>.</p>
<pre><code>(defun last-element (x) (car (last x)))
(define-setf-expander last-element (x &amp;environment env)
  &quot;Set the last element in a list to the given value.&quot;
  (multiple-value-bind (dummies vals newval setter getter) (get-setf-expansion x env)
    (let ((store (gensym)))
          (values dummies
                  vals
                  `(,store)
                  `(progn (rplaca (last ,getter) ,store) ,store)
                  `(lastguy ,getter)))))

(setf l &#39;(a b c d))       ;&rArr; (A B C D)
(last-element l)          ;&rArr; D
(setf (last-element l) 4)
l                         ;&rArr; (A B C 4)</code></pre>
          </div>
        </article>
      </div>

      <aside>
        <div class="section-padding">
          <nav>
<ul>
  <li><a href="#symbol-definition" class="toc-header">Symbol Definition</a></li>
  <li><a href="#style-guides" class="toc-header">Style Guides</a></li>
  <li><a href="#variables" class="toc-header">Variables</a></li>
  <li><a href="#defparameter-name-value-doc-string-name">defparameter</a></li>
  <li><a href="#defvar-name-value-doc-string-name">defvar</a></li>
  <li><a href="#defconstant-name-value-doc-string-name">defconstant</a></li>
  <li><a href="#setf-place-value-result">setf</a></li>
  <li><a href="#let-var-var-value-forms-result">let</a></li>
  <li><a href="#multiple-value-bind-vars-values-form-body-forms-result">multiple-value-bind</a></li>
  <li><a href="#destructuring-bind-lambda-list-expression-forms-result">destructuring-bind</a></li>
  <li><a href="#shiftf-place-newvalue-first-value">shiftf</a></li>
  <li><a href="#rotatef-places-nil">rotatef</a></li>
  <li><a href="#makunbound-symbol-symbol">makunbound</a></li>
  <li><a href="#advanced" class="toc-header">Advanced</a></li>
  <li><a href="#psetf-place-value-nil">psetf</a></li>
  <li><a href="#setq-place-value-result">setq</a></li>
  <li><a href="#psetq-place-value-nil">psetq</a></li>
  <li><a href="#multiple-value-setq-vars-form-result">multiple-value-setq</a></li>
  <li><a href="#progv-symbols-values-forms-result">progv</a></li>
  <li><a href="#functions" class="toc-header">Functions</a></li>
  <li><a href="#defun-name-lambda-list-declare-doc-form-name">defun</a></li>
  <li><a href="#lambda-lambda-list-declare-doc-form-function">lambda</a></li>
  <li><a href="#labels-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result">labels</a></li>
  <li><a href="#function-name-function">function</a></li>
  <li><a href="#funcall-function-args-result">funcall</a></li>
  <li><a href="#apply-function-args-arg-list-result">apply</a></li>
  <li><a href="#multiple-value-call-function-forms-result">multiple-value-call</a></li>
  <li><a href="#values-objects-objects">values</a></li>
  <li><a href="#values-list-list-objects">values-list</a></li>
  <li><a href="#multiple-value-list-form-list">multiple-value-list</a></li>
  <li><a href="#fmakunbound-name-name">fmakunbound</a></li>
  <li><a href="#advanced-1" class="toc-header">Advanced</a></li>
  <li><a href="#flet-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result">flet</a></li>
  <li><a href="#nth-value-n-form-object">nth-value</a></li>
  <li><a href="#function-lambda-expression-function-lambda-expression-closure-p-name">function-lambda-expression</a></li>
  <li><a href="#fdefinition-name-definition">fdefinition</a></li>
  <li><a href="#macros" class="toc-header">Macros</a></li>
  <li><a href="#defmacro-name-lambda-list-declare-doc-forms-name">defmacro</a></li>
  <li><a href="#macrolet-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result">macrolet</a></li>
  <li><a href="#define-symbol-macro-symbol-expansion-symbol">define-symbol-macro</a></li>
  <li><a href="#advanced-2" class="toc-header">Advanced</a></li>
  <li><a href="#symbol-macrolet-symbol-expansion-declare-forms-result">symbol-macrolet</a></li>
  <li><a href="#define-modify-macro-name-lambda-list-function-doc-name">define-modify-macro</a></li>
  <li><a href="#defsetf-access-fn-update-fn-doc-access-fn">defsetf</a></li>
  <li><a href="#get-setf-expansion-place-optional-env-vars-vals-store-vars-writer-form-reader-form">get-setf-expansion</a></li>
  <li><a href="#define-setf-expander-access-fn-lambda-list-declaration-doc-form-access-fn">define-setf-expander</a></li>
</ul>
          </nav>
        </div>
      </aside>
      
      <footer><a href="http://minispec.org">Common Lisp Minispec</a> <a href="https://github.com/lamberta/minispec">&#60;https://github.com/lamberta/minispec&#62;</a></footer>
    </div>

    <script src="./include/jquery.js"></script>
    <script src="./include/typeahead.js"></script>
    <script src="./include/highlight-lisp.js"></script>
    <script src="./include/init.js"></script>
  </body>
</html>
