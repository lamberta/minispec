<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CL MiniSpec: Vectors</title>
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="shortcut icon" href="./include/fav.png">-->
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata">
    <link rel="stylesheet" href="./include/highlight-lisp.css">
    <link rel="stylesheet" href="./include/style.css">
    <meta name="description" content="">
  </head>
  <body>
    <div>

      <header>
        <div class="section-padding">
<nav id="navbar">
	<h1><a href="./index.html" class="brand">Common Lisp MiniSpec</a></h1>
  <ul>
    <li><a href="#"><span class="caret">&#x25BC;</span>Definitions</a>
      <ul>
        <li><a href="./definitions.html#variables">Variables</a></li>
        <li><a href="./definitions.html#functions">Functions</a></li>
        <li><a href="./definitions.html#macros">Macros</a></li>
      </ul>
    </li>
    <li><a href="./lists.html">Lists</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Data Structures</a>
      <ul>
        <li class="navbar-header"><a href="./list-structures.html">List Structures</a></li>
        <li><a href="./list-structures.html#set">Set</a></li>
        <li><a href="./list-structures.html#tree">Tree</a></li>
        <li><a href="./list-structures.html#property-list-plist">Property List</a></li>
        <li><a href="./list-structures.html#association-list-alist">Association List</a></li>
        <li class="navbar-header"><a href="./arrays.html">Array</a></li>
        <li><a href="./arrays.html">Array</a></li>
        <li><a href="./vectors.html">Vector</a></li>
        <li class="navbar-header"><a href="./data-structures.html">Objects</a></li>
        <li><a href="./data-structures.html#hash-tables">Hash Table</a></li>
        <li><a href="./data-structures.html#structures">Structs</a></li>
      </ul>
    </li>
    <li><a href="./clos.html">CLOS</a></li>
    <li><a href="./strings.html">Strings</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Types</a>
      <ul>
        <li><a href="#"></a></li>
        <li><a href="#"></a></li>
      </ul>
    </li>
    <li><a href="./math.html">Math</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>Iteration</a>
      <ul>
        <li><a href="./iteration.html">Iteration</a></li>
        <li><a href="./loop-iterate.html">Loop/Iterate</a></li>
      </ul>
    </li>
    <li><a href="./control.html">Control</a></li>
    <li><a href="#"><span class="caret">&#x25BC;</span>More</a>
      <ul>
        <li><a href="./comparison.html">Comparison</a></li>
        <li><a href="./time.html">Time</a></li>
        <li><a href="./output.html">Output</a></li>
        <li><a href="./regular-expressions.html">Regular Expressions</a></li>
      </ul>
    </li>
		<li><form><input type="search" placeholder="symbol"></input></form></li>
  </ul>
</nav>
        </div>
      </header>
      
      <div class="article-wrapper">
        <article>
          <div class="section-padding">
<h1 id="vectors">Vectors</h1>
<p>A vector is a basic integer-indexed collection, a one-dimensional <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_array.htm">array</a>. Vectors and lists are collectively considered to be <em>sequences</em>.</p>
<ul>
<li><a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node30.html">CLtL2: Vectors</a></li>
<li><a href="http://www.gigamonkeys.com/book/collections.html#vectors">PCL: Vectors</a></li>
</ul>
<h2 id="create">Create</h2>
<h3 id="vector-rest-objects-vector"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_vector.htm">vector</a> &amp;rest objects* &rArr; vector</h3>
<h3 id="make-array-dims-key-type-initial-element-initial-contents-adjustable-fill-pointer-displaced-to-displaced-index-offset-new-array"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_ar.htm">make-array</a> dims &amp;key type initial-element initial-contents adjustable fill-pointer displaced-to displaced-index-offset &rArr; new-array</h3>
<pre><code>(make-array &#39;(2 3)) ;&rArr; #2A((0 0 0) (0 0 0))
(make-array 5 :fill-pointer 0 :adjustable t :element-type &#39;character) ;&rArr; &quot;&quot;</code></pre>
<h3 id="adjust-array-array-new-dims-key-type-initial-element-initial-contents-fill-pointer-displaced-to-displaced-index-offset-adjusted-array"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_adjust.htm">adjust-array</a> array new-dims &amp;key type initial-element initial-contents fill-pointer displaced-to displaced-index-offset &rArr; adjusted-array</h3>
<h3 id="alexandriacopy-array-array-key-element-type-fill-pointer-adjustable-new-array"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-copy_002darray">alexandria:copy-array</a> array &amp;key element-type fill-pointer adjustable &rArr; new-array</h3>
<p>Returns an undisplaced copy of <em>array</em>, with same fill-pointer and adjustability as the original.</p>
<h2 id="select">Select</h2>
<h3 id="svref-simple-vector-index-element"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_svref.htm">svref</a> simple-vector index &rArr; element</h3>
<p>Accesses the element of <em>simple-vector</em> specified by <em>index</em>.</p>
<h3 id="fill-pointer-vector-fill-pointer"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fill_p.htm">fill-pointer</a> vector &rArr; fill-pointer</h3>
<p>Accesses the fill pointer of <em>vector</em>.</p>
<pre><code>(setf arr (make-array 8 :fill-pointer 4)) ;&rArr; #(NIL NIL NIL NIL)
(fill-pointer arr)                        ;&rArr; 4
(vector-push &#39;a arr)
(fill-pointer arr)                        ;&rArr; 5</code></pre>
<h3 id="aref-array-rest-subscripts-element"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_aref.htm">aref</a> array &amp;rest subscripts &rArr; element</h3>
<p>Access array elements. Related: <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_svref.htm">svref</a> —Access index of a simple vector.</p>
<pre><code>(setf a (make-array &#39;(2 2) :initial-contents &#39;((1 2) (3 4))))
(aref a 1 1) ;&rArr; 4
(setf (aref a 0 1) 99) ; a &rArr; #2A((1 99) (3 4))</code></pre>
<h3 id="elt-seq-idx-element"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_elt.htm">elt</a> seq idx &rArr; element</h3>
<p>Related: <code>nth</code>, <code>nthcdr</code>, <code>car</code>, <code>cdr</code>, <code>first</code> … <code>tenth</code></p>
<pre><code>(setf seq &#39;(a b c))
(elt seq 1)             ;&rArr; B
(setf (elt seq 1) &quot;hi&quot;) ; seq &rArr; (A &quot;hi&quot; C)</code></pre>
<h3 id="alexandriarandom-elt"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-random_002delt">alexandria:random-elt</a></h3>
<p>Return a random element from a sequence.</p>
<h3 id="length-seq-n"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_length.htm">length</a> seq &rArr; n</h3>
<pre><code>(length &#39;(a b c)) ;&rArr; 3
(length &quot;hello&quot;)  ;&rArr; 5</code></pre>
<h3 id="find-item-seq-key-from-end-test-test-not-start-end-key-element"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find</a> item seq &amp;key from-end test test-not start end key &rArr; element</h3>
<p>If the sequence <em>seq</em> contains an element satisfying <em>test</em>, then the leftmost such element is returned; otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> is returned. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find-if-not</a>.</p>
<pre><code>(find 3 &#39;(1 2 3 4 5))                            ;&rArr; 3
(find-if #&#39;oddp &#39;(1 2 3 4 5) :end 3 :from-end t) ;&rArr; 3</code></pre>
<h3 id="position-item-seq-key-from-end-test-test-not-start-end-key-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_pos_p.htm">position</a> item seq &amp;key from-end test test-not start end key &rArr; idx</h3>
<p>Return the first index position of an item in the sequence, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>.</p>
<pre><code>(position #\a &quot;baobab&quot; :from-end t)                         ;&rArr; 4
(position-if #&#39;oddp &#39;((1) (2) (3) (4)) :start 1 :key #&#39;car) ;&rArr; 2</code></pre>
<h3 id="count-item-seq-key-from-end-start-end-key-test-test-not-n"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_countc.htm">count</a> item seq &amp;key from-end start end key test test-not &rArr; n</h3>
<p>The number of elements in the specified subsequence of <em>seq</em>. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_countc.htm">count-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_countc.htm">count-if-not</a>.</p>
<pre><code>(count &#39;a &#39;(a b c a))      ;&rArr; 2
(count-if #&#39;oddp &#39;(1 2 3)) ;&rArr; 2</code></pre>
<h3 id="cl-utilitiesextremum-seq-fn-key-key-start-0-end-smallest-element"><a href="http://common-lisp.net/project/cl-utilities/doc/extremum.html">cl-utilities:extremum</a> seq fn &amp;key key (start 0) end &rArr; smallest-element</h3>
<p>Returns first element of <em>sequence</em> if it were ordered by <code>sort</code> using the predicate <em>fn</em>. <code>extrema</code> is similar but returns a list of values since there may be more than one extremum determined by the predicate. <code>n-most-extreme</code> returns a list of <em>n</em> values of a sorted sequence. <a href="http://common-lisp.net/project/cl-utilities/doc/extremum.html">ref</a></p>
<pre><code>(extremum &#39;(1 2 9 7 3 2) #&#39;&gt;)         ;&rArr; 9
(extrema &#39;(1 2 9 7 3 2) #&#39;&gt;)          ;&rArr; (9)
(n-most-extreme 3 &#39;(1 2 9 7 3 2) #&#39;&gt;) ;&rArr; (9 7 3)</code></pre>
<h3 id="subseq-seq-start-optional-end-sub-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_subseq.htm">subseq</a> seq start &amp;optional end &rArr; sub-seq</h3>
<p>Returns the sub-sequence of <em>seq</em> specified by <em>start</em> and <em>end</em>.</p>
<pre><code>(setf str &quot;hello&quot;)
(subseq str 2 4) ;&rArr; &quot;ll&quot;
(setf (subseq str 2 4) &quot;ad&quot;) ; str &rArr; &quot;heado&quot;</code></pre>
<h3 id="search-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_search.htm">search</a> seq1 seq2 &amp;key from-end test test-not key start1 start2 end1 end2 &rArr; idx</h3>
<p>Searches sequence <em>seq2</em> for a sub-sequence that matches <em>seq1</em>. Returns its index position.</p>
<pre><code>(search &#39;(c d) &#39;(a b c d)) ;&rArr; 2
(search &quot;bar&quot; &quot;foobarbaz&quot;) ;&rArr; 3</code></pre>
<h3 id="mismatch-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mismat.htm">mismatch</a> seq1 seq2 &amp;key from-end test test-not key start1 start2 end1 end2 &rArr; idx</h3>
<p>Return the index position where two sequences diverge.</p>
<pre><code>(mismatch &quot;foobarbaz&quot; &quot;foom&quot;) ;&rArr; 3</code></pre>
<h2 id="modify">Modify</h2>
<h3 id="vector-push-new-element-vector-index"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vec_ps.htm">vector-push</a> new-element vector &rArr; index</h3>
<pre><code>(setf v (make-array 2 :fill-pointer 0)) ;&rArr; #()
(vector-push &#39;a v)                      ;&rArr; 0   [v &rArr; #(A)]
(vector-push &#39;b v)                      ;&rArr; 1   [v &rArr; #(A B)]
(vector-push &#39;c v)                      ;&rArr; NIL [v &rArr; #(A B)]</code></pre>
<h3 id="vector-push-extend-new-element-vector-extension-index"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vec_ps.htm">vector-push-extend</a> new-element vector [extension] &rArr; index</h3>
<pre><code>(setf v (make-array 2 :fill-pointer 0 :adjustable t) ;&rArr; #()
(vector-push &#39;a v)                      ;&rArr; 0   [v &rArr; #(A)]
(vector-push &#39;b v)                      ;&rArr; 1   [v &rArr; #(A B)]
(vector-push-extend &#39;c v)               ;&rArr; 2   [v &rArr; #(A B C)]</code></pre>
<h3 id="vector-pop"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vec_po.htm">vector-pop</a></h3>
<p>Decreases the fill pointer of vector by one, and retrieves the element of vector that is designated by the new fill pointer.</p>
<h3 id="concatenate-result-type-rest-seqs-result-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_concat.htm">concatenate</a> result-type &amp;rest seqs… &rArr; result-seq</h3>
<pre><code>(concatenate &#39;list &#39;(a b) &#39;(c d)) ;&rArr; (A B C D)
(concatenate &#39;string &quot;hello&quot; &quot;world&quot;) ;&rArr; &quot;helloworld&quot;</code></pre>
<h3 id="cl-utilitiessplit-sequence-delimiter-seq-key-count-remove-empty-subseqs-from-end-start-end-test-test-not-key-list-idx"><a href="http://common-lisp.net/project/cl-utilities/doc/split-sequence.html">cl-utilities:split-sequence</a> delimiter seq &amp;key count remove-empty-subseqs from-end start end test test-not key &rArr; list, idx</h3>
<p>Splits sequence into a <em>list</em> of subsequences delimited by objects satisfying the test. Also returns the lenbth of the sequence <em>idx</em>. Functional variants are <a href="http://common-lisp.net/project/cl-utilities/doc/split-sequence.html">cl-utilities:split-sequence-if</a> and <a href="http://common-lisp.net/project/cl-utilities/doc/split-sequence.html">cl-utilities:split-sequence-if-not</a>.</p>
<pre><code>(split-sequence #\Space &quot;hello world&quot;)           ;&rArr; (&quot;hello&quot; &quot;world&quot;), 11
(split-sequence-if #&#39;evenp &#39;(1 1 2 1 3 4 1 3 5)) ;&rArr; ((1 1) (1 3) (1 3 5)), 9</code></pre>
<h3 id="fill-seq-item-key-start-end-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fill.htm">fill</a> seq item &amp;key start end &rArr; seq</h3>
<p>Destructively replaces the elements of <em>seq</em> bounded by <em>:start</em> and <em>:end</em> with <em>item</em>.</p>
<pre><code>(fill &#39;(a b c d) &#39;x :start 1 :end 3) ;&rArr; (A X X D)</code></pre>
<h3 id="replace-seq1-seq2-key-start1-end1-start2-end2-seq1"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_replac.htm">replace</a> seq1 seq2 &amp;key start1 end1 start2 end2 &rArr; seq1</h3>
<p>Destructively replaces the elements of <em>se1</em> bounded by <em>:start1</em> and <em>:end1</em> with the elements of <em>seq2</em> bounded by <em>:start2</em> and <em>:end2</em>.</p>
<pre><code>(replace &quot;abcde&quot; &quot;98765&quot; :start1 1 :end1 3 :start2 3) ;&rArr; &quot;a65de&quot;</code></pre>
<p>To remove an element from a sequence at a given position:</p>
<pre><code>(setf lst &#39;(a b c d e))
(setf i (position &#39;b lst))                 ;&rArr; 1
(replace lst lst :start1 i :start2 (1+ i)) ;&rArr; (A C D E E)
(butlast lst)                              ;&rArr; (A C D E)</code></pre>
<h3 id="substitute-new-old-seq-key-from-end-test-test-not-start-end-count-key"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute</a> new old seq &amp;key from-end test test-not start end count key</h3>
<p>Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute-if</a>, <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute-if-not</a>. Destructive variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">nsubstitute</a>, <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">nsubstitute-if</a>, and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">nsubstitute-if-not</a>. <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst</a> performs substitutions throughout a <em>tree</em>.</p>
<pre><code>(substitute 10 1 &#39;(1 2 1 3 1 4))      ;&rArr; (10 2 10 3 10 4)
(substitute-if 0 #&#39;oddp &#39;(1 2 3 4 5)) ;&rArr; (0 2 0 4 0)</code></pre>
<h3 id="remove-item-seq-key-from-end-test-test-not-start-end-count-key-result-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove</a> item seq &amp;key from-end test test-not start end count key &rArr; result-seq</h3>
<p>Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove-if-not</a>. The destructive variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">delete</a>, <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">delete-if</a>, and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">delete-if-not</a>. To remove in place, use <a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-removef">alexandria:removef</a> or <a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-deletef">alexandria:deletef</a>.</p>
<pre><code>(remove 4 &#39;(1 2 4 1 3 4 5))           ;&rArr; (1 2 1 3 5)
(remove-if #&#39;oddp &#39;(1 2 4 1 3 4 5))   ;&rArr; (2 4 4)
(remove-if-not #&#39;oddp &#39;(1 2 1 3 4 5)) ;&rArr; (1 1 3 5)</code></pre>
<h3 id="remove-duplicates-seq-key-from-end-test-test-not-start-end-key"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_dup.htm">remove-duplicates</a> seq &amp;key from-end test test-not start end key</h3>
<p>Destructive variant is <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_dup.htm">delete-duplicates</a>.</p>
<pre><code>(remove-duplicates &#39;(1 2 1 2 3 1 2 3 4)) ;&rArr; (1 2 3 4)</code></pre>
<h2 id="sort">Sort</h2>
<h2 id="sort-1">Sort</h2>
<h3 id="reverse-seq-reversed-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_revers.htm">reverse</a> seq &rArr; reversed-seq</h3>
<p>Reverse the order of elements in a sequence. The destructive version is <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_revers.htm">nreverse</a>. To save the result in place, use <a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-reversef">alexandria:reversef</a>.</p>
<pre><code>(reverse &#39;(a b c d)) ;&rArr; (D C B A)</code></pre>
<h3 id="sort-seq-fn-key-key-sorted-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sort_.htm">sort</a> seq fn &amp;key key &rArr; sorted-seq</h3>
<p>The sequence is destructively sorted according to an order determined by the predicate <em>fn</em>. <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sort_.htm">stable-sort</a> guarantees equal elements stay in same order.</p>
<pre><code>(sort &#39;(3 1 4 2) (lambda (x y) (&lt; x y))) ;&rArr; (1 2 3 4)</code></pre>
<h3 id="merge-result-type-seq1-seq2-fn-key-key-result-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_merge.htm">merge</a> result-type seq1 seq2 fn &amp;key key &rArr; result-seq</h3>
<p>Destructively concatenates the two sequences and sorts the combined elements based on the predicate <em>fn</em>.</p>
<pre><code>(merge &#39;list &#39;(1 3 5) &#39;(2 4 6) #&#39;&lt;) ;&rArr; (1 2 3 4 5 6)</code></pre>
<h3 id="alexandriarotate-seq-optional-n-result-seq"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-rotate">alexandria:rotate</a> seq &amp;optional n &rArr; result-seq</h3>
<p>Returns a <em>sequence</em> with elements rotated by <em>n</em>, defaulting to 1.</p>
<pre><code>(rotate &#39;(a b c))    ;&rArr; (C A B)
(rotate &#39;(a b c) -1) ;&rArr; (B C A)</code></pre>
<h3 id="alexandriashuffle-seq-key-start-end-result-seq"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-shuffle">alexandria:shuffle</a> seq &amp;key start end &rArr; result-seq</h3>
<p>Returns a random permutation of a sequence bounded by <em>:start</em> and <em>:end</em>. The original sequence may be modified.</p>
<h2 id="predicates">Predicates</h2>
<h3 id="some-fn-seq-rest-seqs-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">some</a> fn seq &amp;rest seqs* &rArr; result</h3>
<p>Returns the first non-<a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> value which is returned by an invocation of the predicate <em>fn</em>.</p>
<pre><code>(some #&#39;evenp &#39;(1 2 3 4))  ;&rArr; T
(some #&#39;1+ &#39;(10 20 30 40)) ;&rArr; 11
(some #&#39;numberp &#39;(a b c))  ;&rArr; NIL</code></pre>
<h3 id="every-fn-seq-rest-seqs-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">every</a> fn seq &amp;rest seqs* &rArr; boolean</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> as soon as any invocation of the predicate <em>fn</em> returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>.</p>
<pre><code>(every #&#39;numberp &#39;(1 2 3 4)) ;&rArr; T
(every #&#39;evenp &#39;(1 2 3 4))   ;&rArr; NIL</code></pre>
<h3 id="notevery-fn-seq-rest-seqs-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">notevery</a> fn seq &amp;rest seqs* &rArr; boolean</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a> as soon as any invocation of predicate <em>fn</em> returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>.</p>
<pre><code>(notevery #&#39;numberp &#39;(1 2 3 4)) ;&rArr; NIL
(notevery #&#39;evenp &#39;(1 2 3 4))   ;&rArr; T</code></pre>
<h3 id="notany-fn-seq-rest-seqs-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_everyc.htm">notany</a> fn seq &amp;rest seqs* &rArr; boolean</h3>
<p>Returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> as soon as any invocation of predicate <em>fn</em> returns <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_t.htm">t</a>.</p>
<pre><code>(notany #&#39;numberp &#39;(1 2 3 4)) ;&rArr; NIL
(notany #&#39;evenp &#39;(1 2 3 4))   ;&rArr; NIL</code></pre>
<h3 id="arrayp"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_arrayp.htm">arrayp</a></h3>
<h3 id="vectorp"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vecp.htm">vectorp</a></h3>
<h3 id="simple-vector-p"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_smp_ve.htm">simple-vector-p</a></h3>
<h3 id="bit-vector-p"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_bt_vec.htm">bit-vector-p</a></h3>
<h3 id="simple-bit-vector-p"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_smp_bt.htm">simple-bit-vector-p</a></h3>
<h3 id="adjustable-array-p"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_adju_1.htm">adjustable-array-p</a></h3>
<h3 id="array-has-fill-pointer-p"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_ar_has.htm">array-has-fill-pointer-p</a></h3>
<h3 id="array-in-bounds-p"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_ar_in_.htm">array-in-bounds-p</a></h3>
<h2 id="iteration">Iteration</h2>
<h3 id="map-result-type-fn-rest-seqs-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_map.htm">map</a> result-type fn &amp;rest seqs* &rArr; result</h3>
<p>Applies the function to elements of each sequence in turn. The result sequence is as long as the shortest of the sequences.</p>
<pre><code>(map &#39;list #&#39;cons &#39;(a b) &#39;(c d))              ;&rArr; ((A . C) (B . D))
(map &#39;vector #&#39;(lambda (x) (* 2 x)) &#39;(1 2 3)) ;&rArr; #(2 4 6)</code></pre>
<h3 id="map-into-result-seq-fn-rest-seqs-result-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_map_in.htm">map-into</a> result-seq fn &amp;rest seqs* &rArr; result-seq</h3>
<p>Destructively modifies <em>result-seq</em> to contain the results of applying the function to each element in the argument <em>seqs</em> in turn.</p>
<pre><code>(map-into &#39;(a b c) #&#39;oddp &#39;(1 2 3 4 5 6)) ;&rArr; (T NIL T)</code></pre>
<h3 id="remove-if-not-fn-seq-key-from-end-start-end-count-key-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove-if-not</a> fn seq &amp;key from-end start end count key &rArr; seq</h3>
<p>Filter</p>
<pre><code>(remove-if-not #&#39;oddp &#39;(0 1 2 3 4)) ;&rArr; (1 3)
(remove-if-not (alexandria:disjoin #&#39;zerop #&#39;oddp) &#39;(0 1 2 3 4)) ;&rArr; (0 1 3)</code></pre>
<h3 id="remove-if-fn-seq-key-from-end-start-end-count-key-seq"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove-if</a> fn seq &amp;key from-end start end count key &rArr; seq</h3>
<pre><code>(remove-if #&#39;oddp &#39;(0 1 2 3 4)) ;&rArr; (0 2 4)
(remove-if (alexandria:disjoin #&#39;zerop #&#39;oddp) &#39;(0 1 2 3 4)) ;&rArr; (2 4)</code></pre>
<h3 id="reduce-fn-seq-key-key-from-end-start-end-initial-value-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_reduce.htm">reduce</a> fn seq &amp;key key from-end start end initial-value &rArr; result</h3>
<pre><code>(reduce #&#39;* &#39;(1 2 3 4 5)) ;&rArr; 120</code></pre>
<h3 id="alexandriamap-combinations-fn-seq-key-start-end-length-copy"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-map_002dcombinations">alexandria:map-combinations</a> fn seq &amp;key start end length copy</h3>
<h3 id="alexandriamap-derangements-fn-seq-key-start-end-copy"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-map_002dderangements">alexandria:map-derangements</a> fn seq &amp;key start end copy</h3>
<h3 id="alexandriamap-permutations-fn-seq-key-start-end-length-copy"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-map_002dpermutations">alexandria:map-permutations</a> fn seq &amp;key start end length copy</h3>
          </div>
        </article>
      </div>

      <aside>
        <div class="section-padding">
          <nav>
<ul>
  <li><a href="#vectors" class="toc-header">Vectors</a></li>
  <li><a href="#create" class="toc-header">Create</a></li>
  <li><a href="#vector-rest-objects-vector">vector</a></li>
  <li><a href="#make-array-dims-key-type-initial-element-initial-contents-adjustable-fill-pointer-displaced-to-displaced-index-offset-new-array">make-array</a></li>
  <li><a href="#adjust-array-array-new-dims-key-type-initial-element-initial-contents-fill-pointer-displaced-to-displaced-index-offset-adjusted-array">adjust-array</a></li>
  <li><a href="#alexandriacopy-array-array-key-element-type-fill-pointer-adjustable-new-array">copy-array</a></li>
  <li><a href="#select" class="toc-header">Select</a></li>
  <li><a href="#svref-simple-vector-index-element">svref</a></li>
  <li><a href="#fill-pointer-vector-fill-pointer">fill-pointer</a></li>
  <li><a href="#aref-array-rest-subscripts-element">aref</a></li>
  <li><a href="#elt-seq-idx-element">elt</a></li>
  <li><a href="#alexandriarandom-elt">random-elt</a></li>
  <li><a href="#length-seq-n">length</a></li>
  <li><a href="#find-item-seq-key-from-end-test-test-not-start-end-key-element">find</a></li>
  <li><a href="#position-item-seq-key-from-end-test-test-not-start-end-key-idx">position</a></li>
  <li><a href="#count-item-seq-key-from-end-start-end-key-test-test-not-n">count</a></li>
  <li><a href="#cl-utilitiesextremum-seq-fn-key-key-start-0-end-smallest-element">extremum</a></li>
  <li><a href="#subseq-seq-start-optional-end-sub-seq">subseq</a></li>
  <li><a href="#search-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx">search</a></li>
  <li><a href="#mismatch-seq1-seq2-key-from-end-test-test-not-key-start1-start2-end1-end2-idx">mismatch</a></li>
  <li><a href="#modify" class="toc-header">Modify</a></li>
  <li><a href="#vector-push-new-element-vector-index">vector-push</a></li>
  <li><a href="#vector-push-extend-new-element-vector-extension-index">vector-push-extend</a></li>
  <li><a href="#vector-pop">vector-pop</a></li>
  <li><a href="#concatenate-result-type-rest-seqs-result-seq">concatenate</a></li>
  <li><a href="#cl-utilitiessplit-sequence-delimiter-seq-key-count-remove-empty-subseqs-from-end-start-end-test-test-not-key-list-idx">split-sequence</a></li>
  <li><a href="#fill-seq-item-key-start-end-seq">fill</a></li>
  <li><a href="#replace-seq1-seq2-key-start1-end1-start2-end2-seq1">replace</a></li>
  <li><a href="#substitute-new-old-seq-key-from-end-test-test-not-start-end-count-key">substitute</a></li>
  <li><a href="#remove-item-seq-key-from-end-test-test-not-start-end-count-key-result-seq">remove</a></li>
  <li><a href="#remove-duplicates-seq-key-from-end-test-test-not-start-end-key">remove-duplicates</a></li>
  <li><a href="#sort" class="toc-header">Sort</a></li>
  <li><a href="#sort-1" class="toc-header">Sort</a></li>
  <li><a href="#reverse-seq-reversed-seq">reverse</a></li>
  <li><a href="#sort-seq-fn-key-key-sorted-seq">sort</a></li>
  <li><a href="#merge-result-type-seq1-seq2-fn-key-key-result-seq">merge</a></li>
  <li><a href="#alexandriarotate-seq-optional-n-result-seq">rotate</a></li>
  <li><a href="#alexandriashuffle-seq-key-start-end-result-seq">shuffle</a></li>
  <li><a href="#predicates" class="toc-header">Predicates</a></li>
  <li><a href="#some-fn-seq-rest-seqs-result">some</a></li>
  <li><a href="#every-fn-seq-rest-seqs-boolean">every</a></li>
  <li><a href="#notevery-fn-seq-rest-seqs-boolean">notevery</a></li>
  <li><a href="#notany-fn-seq-rest-seqs-boolean">notany</a></li>
  <li><a href="#arrayp">arrayp</a></li>
  <li><a href="#vectorp">vectorp</a></li>
  <li><a href="#simple-vector-p">simple-vector-p</a></li>
  <li><a href="#bit-vector-p">bit-vector-p</a></li>
  <li><a href="#simple-bit-vector-p">simple-bit-vector-p</a></li>
  <li><a href="#adjustable-array-p">adjustable-array-p</a></li>
  <li><a href="#array-has-fill-pointer-p">array-has-fill-pointer-p</a></li>
  <li><a href="#array-in-bounds-p">array-in-bounds-p</a></li>
  <li><a href="#iteration" class="toc-header">Iteration</a></li>
  <li><a href="#map-result-type-fn-rest-seqs-result">map</a></li>
  <li><a href="#map-into-result-seq-fn-rest-seqs-result-seq">map-into</a></li>
  <li><a href="#remove-if-not-fn-seq-key-from-end-start-end-count-key-seq">remove-if-not</a></li>
  <li><a href="#remove-if-fn-seq-key-from-end-start-end-count-key-seq">remove-if</a></li>
  <li><a href="#reduce-fn-seq-key-key-from-end-start-end-initial-value-result">reduce</a></li>
  <li><a href="#alexandriamap-combinations-fn-seq-key-start-end-length-copy">map-combinations</a></li>
  <li><a href="#alexandriamap-derangements-fn-seq-key-start-end-copy">map-derangements</a></li>
  <li><a href="#alexandriamap-permutations-fn-seq-key-start-end-length-copy">map-permutations</a></li>
</ul>
          </nav>
        </div>
      </aside>
      
      <footer><a href="http://minispec.org">Common Lisp Minispec</a> <a href="https://github.com/lamberta/minispec">&#60;https://github.com/lamberta/minispec&#62;</a></footer>
    </div>

    <script src="./include/jquery.js"></script>
    <script src="./include/typeahead.js"></script>
    <script src="./include/highlight-lisp.js"></script>
    <script src="./include/init.js"></script>
  </body>
</html>
