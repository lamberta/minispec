<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CL MiniSpec: List Structures</title>
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="shortcut icon" href="./include/fav.png">-->
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata">
    <link rel="stylesheet" href="./include/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="./include/typeahead/typeahead.js-bootstrap.css">
    <link rel="stylesheet" href="./include/highlight/themes/github.css">
    <link rel="stylesheet" href="./include/style.css">
    <meta name="description" content="">
  </head>
  <body>
    <header>
<nav class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container-fluid">
      <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a href="./index.html" class="brand">Common Lisp MiniSpec</a>
      <form class="navbar-search pull-right"><input type="search" placeholder="symbol" class="search-query span2"></input></form>
      <div class="nav-collapse collapse">
        <ul class="nav pull-right">
          <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Definitions<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="./definitions.html#variables">Variables</a></li>
              <li><a href="./definitions.html#functions">Functions</a></li>
              <li><a href="./definitions.html#macros">Macros</a></li>
            </ul>
          </li>
          <li><a href="./lists.html">Lists</a></li>
          <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Data Structures<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li class="nav-header"><a href="./list-structures.html">List Structures</a></li>
              <li><a href="./list-structures.html#set">Set</a></li>
              <li><a href="./list-structires.html#tree">Tree</a></li>
              <li><a href="./list-structures.html#plist">Property List</a></li>
              <li><a href="./list-structures.html#alist">Association List</a></li>
              <li class="nav-header"><a href="./arrays.html">Array</a></li>
              <li><a href="./arrays.html">Array</a></li>
              <li><a href="./vectors.html">Vector</a></li>
              <li class="nav-header"><a href="./data-structures.html">Objects</a></li>
              <li><a href="./data-structures.html#hash-tables">Hash Table</a></li>
              <li><a href="./data-structures.html#structs">Structs</a></li>
              <li><a href="./clos.html">Common Lisp Object System</a></li>
            </ul>
          </li>
          <li><a href="./strings.html">Strings</a></li>
          <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Types<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="#">Numbers</a></li>
              <li><a href="#">Characters</a></li>
            </ul>
          </li>
          <li><a href="./math.html">Math</a></li>
          <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Iteration<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="./iteration.html">Iteration</a></li>
              <li><a href="./loop-iterate.html">Loop/Iterate</a></li>
            </ul>
          </li>
          <li><a href="./control.html">Control</a></li>
          <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">More<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="./time.html">Time</a></li>
              <li><a href="./output.html">Output</a></li>
              <li><a href="./regular-expressions.html">Regular Expressions</a></li>
            </ul>
          </li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</nav>
    </header>
    <div id="container" class="container-fluid">
      <div class="row-fluid">
        <aside class="span3">
          <nav class="well" data-spy="affix">
<ul class="nav nav-list">
  <li><a href="#list-structures" class="nav-header">List Structures</a></li>
  <li><a href="#set" class="nav-header">Set</a></li>
  <li><a href="#alexandriasetp-object-key-test-key-boolean">setp</a></li>
  <li><a href="#subsetp-list1-list2-key-key-test-test-not-boolean">subsetp</a></li>
  <li><a href="#alexandriaset-equal-list1-list2-key-test-key-boolean">set-equal</a></li>
  <li><a href="#member-item-list-key-key-test-test-not-tail">member</a></li>
  <li><a href="#adjoin-item-list-key-key-test-test-not-new-list">adjoin</a></li>
  <li><a href="#union-list1-list2-key-key-test-test-not-result-list">union</a></li>
  <li><a href="#intersection-list1-list2-key-key-test-test-not-result-list">intersection</a></li>
  <li><a href="#set-difference-list1-list2-key-key-test-test-not-result-list">set-difference</a></li>
  <li><a href="#set-exclusive-or-list1-list2-key-key-test-test-not-result-list">set-exclusive-or</a></li>
  <li><a href="#tree" class="nav-header">Tree</a></li>
  <li><a href="#tree-equal">tree-equal</a></li>
  <li><a href="#copy-tree-tree-new-tree">copy-tree</a></li>
  <li><a href="#subst-new-old-tree-key-key-test-test-not-new-tree">subst</a></li>
  <li><a href="#sublis-alist-tree-key-key-test-test-not-new-tree">sublis</a></li>
  <li><a href="#alexandriaflatten-tree-list">flatten</a></li>
  <li><a href="#alexandriacircular-tree-p-object-boolean">circular-tree-p</a></li>
  <li><a href="#property-lists-plist" class="nav-header">Property Lists (plist)</a></li>
  <li><a href="#getf-plist-indicator-optional-default-value">getf</a></li>
  <li><a href="#remf-place-indicator-boolean">remf</a></li>
  <li><a href="#get-properties-plist-indicator-list-indicator-value-tail">get-properties</a></li>
  <li><a href="#alexandriaplist-alist-plist">plist-alist</a></li>
  <li><a href="#alexandriaplist-hash-table-plist-rest-hash-table-initargs">plist-hash-table</a></li>
  <li><a href="#alexandriaremove-from-plist-plist-rest-keys">remove-from-plist</a></li>
  <li><a href="#alexandriaremove-from-plistf-plist-rest-keys">remove-from-plistf</a></li>
  <li><a href="#alexandriadoplist-key-val-plist-optional-values-forms">doplist</a></li>
  <li><a href="#association-list-alist" class="nav-header">Association List (alist)</a></li>
  <li><a href="#acons-key-datum-alist-new-alist">acons</a></li>
  <li><a href="#pairlis-keys-data-optional-alist-new-alist">pairlis</a></li>
  <li><a href="#assoc-item-alist-key-key-test-test-not-entry">assoc</a></li>
  <li><a href="#copy-alist-alist-new-alist">copy-alist</a></li>
  <li><a href="#alexandriaalist-plist-alist">alist-plist</a></li>
</ul>
          </nav>
        </aside>
        <article class="span9">
<h1 id="list-structures">List Structures</h1>
<h2 id="set">Set</h2>
<ul>
<li><a href="http://www.gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html#sets">PCL: Beyond Lists: Other Uses for Cons Cells</a></li>
</ul>
<h3 id="alexandriasetp-object-key-test-key-boolean"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-setp">alexandria:setp</a> object &amp;key test key &rArr; boolean</h3>
<p>Test if <em>object</em> is a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a> containing unique elements.</p>
<pre><code>(setp &#39;(a b c)) ;&rArr; T
(setp &#39;(a b b)) ;&rArr; NIL
(setp &#39;((10 :a) (10.0 :b)) :key #&#39;car)           ;&rArr; T
(setp &#39;((10 :a) (10.0 :b)) :key #&#39;car :test #&#39;=) ;&rArr; NIL</code></pre>
<h3 id="subsetp-list1-list2-key-key-test-test-not-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_subset.htm">subsetp</a> list1 list2 &amp;key key test test-not &rArr; boolean</h3>
<p>Test if every element of <em>list1</em> matches an element in <em>list2</em>.</p>
<pre><code>(subsetp &#39;(c b a) &#39;(a b c d)) ;&rArr; T
(subsetp &#39;(a b c d) &#39;(c b a)) ;&rArr; NIL</code></pre>
<h3 id="alexandriaset-equal-list1-list2-key-test-key-boolean"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-set_002dequal">alexandria:set-equal</a> list1 list2 &amp;key test key &rArr; boolean</h3>
<p>Test if every element in <em>list1</em> matches an element in <em>list2</em>, and vice-versa.</p>
<pre><code>(set-equal &#39;(a b c) &#39;(c b a)) ;&rArr; T
(set-equal &#39;(a b) &#39;(a b c))   ;&rArr; NIL</code></pre>
<h3 id="member-item-list-key-key-test-test-not-tail"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_member.htm">member</a> item list &amp;key key test test-not &rArr; tail</h3>
<p>Similiar to <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_find_.htm">find</a>, but if the item is in the list return the tail, otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mem_m.htm">member-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mem_m.htm">member-if-not</a>.</p>
<pre><code>(member &#39;c &#39;(a b c d))             ;&rArr; (C D)
(member-if #&#39;evenp &#39;(1 2 3 4))     ;&rArr; (2 3 4)
(member-if-not #&#39;evenp &#39;(1 2 3 4)) ;&rArr; (1 2 3 4)</code></pre>
<h3 id="adjoin-item-list-key-key-test-test-not-new-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_adjoin.htm">adjoin</a> item list &amp;key key test test-not &rArr; new-list</h3>
<p>Add item to <em>list</em> if not already there, otherwise return original list. Use <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_pshnew.htm">pushnew</a> to modify the original list.</p>
<h3 id="union-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_unionc.htm">union</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>To save the result in place, use <a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-unionf">alexandria:unionf</a>.</p>
<pre><code>(union &#39;(a b c) &#39;(f a d)) ;&rArr; (A B C D F)</code></pre>
<h3 id="intersection-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_isec_.htm">intersection</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>Return a list that contains every element in both <em>list1</em> and <em>list2</em>.</p>
<pre><code>(intersection &#39;(a b c) &#39;(b c d)) ;&rArr; (B C)</code></pre>
<h3 id="set-difference-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_set_di.htm">set-difference</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>Returns a list of elements of <em>list1</em> that do not appear in <em>list2</em>.</p>
<pre><code>(set-difference &#39;(a b c e) &#39;(b c d)) ;&rArr; (A E)</code></pre>
<h3 id="set-exclusive-or-list1-list2-key-key-test-test-not-result-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_set_ex.htm">set-exclusive-or</a> list1 list2 &amp;key key test test-not &rArr; result-list</h3>
<p>Returns a list of elements that appear in exactly one of <em>list1</em> and <em>list2</em>.</p>
<pre><code>(set-exclusive-or &#39;(a b c e) &#39;(b c d)) ;&rArr; (A D E)</code></pre>
<h2 id="tree">Tree</h2>
<p>Lists of lists.</p>
<ul>
<li><a href="http://www.gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html#trees">PCL: Beyond Lists: Other Uses for Cons Cells</a></li>
</ul>
<h3 id="tree-equal"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_tree_e.htm">tree-equal</a></h3>
<p>Compares two trees, equal if structure is same shape and leaves are eql (or :test).</p>
<h3 id="copy-tree-tree-new-tree"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cp_tre.htm">copy-tree</a> tree &rArr; new-tree</h3>
<p>Creates a copy of a <em>tree</em> of conses.</p>
<h3 id="subst-new-old-tree-key-key-test-test-not-new-tree"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst</a> new old tree &amp;key key test test-not &rArr; new-tree</h3>
<p>Make a copy of <em>tree</em> with each subtree or leaf matching <em>old</em> replaced by <em>new</em>, the tree counterpart to <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sbs_s.htm">substitute</a>. Functional variants are <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst-if</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">subst-if-not</a>, called on each atomic value in the tree. The destructive version is <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_substc.htm">nsubst</a> and variants.</p>
<pre><code>(subst &quot;two&quot; 2 &#39;(1 (1 2) (1 (2 3)))) ;&rArr; (1 (1 &quot;two&quot;) (1 (&quot;two&quot; 3)))
(subst-if &quot;one&quot; #&#39;(lambda (x) (equal x 1)) &#39;(1 2 (3 2 1))) ;&rArr; (&quot;one&quot; 2 (3 2 &quot;one&quot;)))</code></pre>
<h3 id="sublis-alist-tree-key-key-test-test-not-new-tree"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_sublis.htm">sublis</a> alist tree &amp;key key test test-not &rArr; new-tree</h3>
<p>Make a tree copy and substitute multiple leaves using an <em>alist</em>.</p>
<pre><code>(sublis &#39;((1 . &quot;one&quot;) (2 . &quot;two&quot;)) &#39;(1 (1 2) (1 (2 3))))
  ;&rArr; (&quot;one&quot; (&quot;one&quot; &quot;two&quot;) (&quot;one&quot; (&quot;two&quot; 3))))</code></pre>
<h3 id="alexandriaflatten-tree-list"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-flatten">alexandria:flatten</a> tree &rArr; list</h3>
<p>Collect non-null leaves into a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a>.</p>
<pre><code>(flatten &#39;(1 2 (3 2 1) ((1 1 nil) (2 2)))) ;&rArr; (1 2 3 2 1 1 1 2 2)</code></pre>
<h3 id="alexandriacircular-tree-p-object-boolean"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-circular_002dtree_002dp">alexandria:circular-tree-p</a> object &rArr; boolean</h3>
<p>Test if <em>object</em> is a circular <em>tree</em>.</p>
<h2 id="property-lists-plist">Property Lists (plist)</h2>
<p>Lists with alternating keys and values: <code>(:x 10 :y 20)</code>. Uses <code>#'eq</code> for <code>:test</code>, so should only use symbols as keywords.</p>
<p>Every symbol contains metadata on it stored as a plist:</p>
<pre><code>(symbol-plist &#39;symbol) ;access plist of symbol
(get &#39;symbol &#39;key) ;equivalent to (getf (symbol-plist &#39;symbol)
(setf (get &#39;symbol :my-key) &quot;information&quot;) ;set value
(remprop &#39;symbol &#39;my-key) ;remove property, same as (remf (symbol-plist &#39;symbol) &#39;my-key)</code></pre>
<h3 id="getf-plist-indicator-optional-default-value"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_getf.htm">getf</a> plist indicator &amp;optional default &rArr; value</h3>
<pre><code>(getf plist :x)           ;&rArr; 10
(setf (getf plist :x) 30) ;&rArr; 30</code></pre>
<h3 id="remf-place-indicator-boolean"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_remf.htm">remf</a> place indicator &rArr; boolean</h3>
<pre><code>(remf plist :x) ;&rArr; T</code></pre>
<h3 id="get-properties-plist-indicator-list-indicator-value-tail"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_get_pr.htm">get-properties</a> plist indicator-list &rArr; indicator, value, tail</h3>
<p>Used since <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_getf.htm">getf</a> canâ€™t distinguish an absent property from <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a>. Returns on the first key found.</p>
<pre><code>(get-properties plist &#39;(:x :y)) ;&rArr; :X, 10, (:X 10 :Y 20)</code></pre>
<h3 id="alexandriaplist-alist-plist"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-plist_002dalist">alexandria:plist-alist</a> plist</h3>
<h3 id="alexandriaplist-hash-table-plist-rest-hash-table-initargs"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-plist_002dhash_002dtable">alexandria:plist-hash-table</a> plist &amp;rest hash-table-initargs</h3>
<h3 id="alexandriaremove-from-plist-plist-rest-keys"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-remove_002dfrom_002dplist">alexandria:remove-from-plist</a> plist &amp;rest keys</h3>
<h3 id="alexandriaremove-from-plistf-plist-rest-keys"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-remove_002dfrom_002dplistf">alexandria:remove-from-plistf</a> plist &amp;rest keys</h3>
<p>destructive</p>
<h3 id="alexandriadoplist-key-val-plist-optional-values-forms"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-doplist">alexandria:doplist</a> (key val plist &amp;optional values) forms*</h3>
<h2 id="association-list-alist">Association List (alist)</h2>
<h3 id="acons-key-datum-alist-new-alist"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_acons.htm">acons</a> key datum alist &rArr; new-alist</h3>
<p>Append a <em>cons</em> and return a new <em>alist</em>. To modify an <em>alist</em> in place, use <code>push</code>.</p>
<pre><code>(acons :c 3 &#39;((:B . 2) (:A . 1))) ;&rArr; ((:C . 3) (:B . 2) (:A . 1))
(push (cons :c 3) alist)          ;&rArr; ((:C . 3) (:B . 2) (:A . 1))</code></pre>
<h3 id="pairlis-keys-data-optional-alist-new-alist"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_pairli.htm">pairlis</a> keys data &amp;optional alist &rArr; new-alist</h3>
<p>Pair up elements in <em>keys</em> and <em>data</em> lists to make an <em>alist</em>.</p>
<pre><code>(pairlis &#39;(:a :b) &#39;(1 2)) ;&rArr; ((:B . 2) (:A . 1))</code></pre>
<h3 id="assoc-item-alist-key-key-test-test-not-entry"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_assocc.htm">assoc</a> item alist &amp;key key test test-not &rArr; entry</h3>
<p>Return the alist entry whose <em>car</em> satisfies the test, or <em>nil</em>. Functional variants are <code>assoc-if</code> and <code>assoc-if-not</code>. <code>rassoc</code> uses <em>cdr</em> to test.</p>
<pre><code>(assoc :a &#39;((:A . 1) (:B . 2)))         ;&rArr; (:A . 1)
(rassoc 1 &#39;((:A . 1) (:B . 2)))         ;&rArr; (:A . 1)
(assoc-if #&#39;evenp &#39;((1 . :A) (2 . :B))) ;&rArr; (2 . :B)</code></pre>
<h3 id="copy-alist-alist-new-alist"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cp_ali.htm">copy-alist</a> alist &rArr; new-alist</h3>
<p>Copies the <em>cons</em> cells that make up the alist structure.</p>
<h3 id="alexandriaalist-plist-alist"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-alist_002dplist">alexandria:alist-plist</a> alist</h3>
<p>Converts an <em>alist</em> to a <em>plist</em> format.</p>
<pre><code>(alist-plist &#39;((:x . 10) (:y . 20))) ;&rArr; (:x 10 :y 20)</code></pre>
        </article>
      </div>
    </div>
    <footer></footer>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="./include/bootstrap/js/bootstrap.js"></script>
    <script src="./include/typeahead/typeahead.min.js"></script>
    <script src="./include/highlight/highlight-lisp.js"></script>
    <script src="./include/init.js"></script>
  </body>
</html>
